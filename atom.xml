<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>즐거이 배우고 깊이 생각하라</title>
  
  <subtitle>즐거이 배우고 깊이 생각하라</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyunto.github.io/"/>
  <updated>2019-08-08T14:23:01.952Z</updated>
  <id>https://hyunto.github.io/</id>
  
  <author>
    <name>hyunto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Private 메소드 테스트하기</title>
    <link href="https://hyunto.github.io/2019/03/13/springframework-testing-private-method/"/>
    <id>https://hyunto.github.io/2019/03/13/springframework-testing-private-method/</id>
    <published>2019-03-13T06:08:30.000Z</published>
    <updated>2019-08-08T14:23:01.952Z</updated>
    
    <content type="html"><![CDATA[<p>단위 테스트 작성시 Private 접근자를 가진 메소드를 테스트하는 방법을 정리합니다.</p><a id="more"></a><p>2가지 방식으로 Private 접근자를 가진 메소드를 단위테스트하는 예제입니다.</p><ul><li>Reflection 활용</li><li>Spring Framework의 RelectionTestUtils </li></ul><h3 id="Reflection을-활용한-private-static-메서드-단위-테스트"><a href="#Reflection을-활용한-private-static-메서드-단위-테스트" class="headerlink" title="Reflection을 활용한 private static 메서드 단위 테스트"></a>Reflection을 활용한 private static 메서드 단위 테스트</h3><p>Relection으로 특정 클래스에서 테스트 할 메서드를 불러온 후 <code>accessible 필드</code>를 <code>true</code>로 설정합니다.<br>그리고 <code>invoke()</code> 메서드를 사용해 테스트 할 Private 메서드를 실행합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkLength</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.length() &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckLength</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Method checkLength = Validator.class.getDeclaredMethod(<span class="string">"checkLength"</span>, String.class);</span><br><span class="line">checkLength.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = (<span class="keyword">boolean</span>)checkLength.invoke(checkLength, <span class="string">"abcdefghijklmn"</span>);</span><br><span class="line">assertFalse(result);</span><br><span class="line"></span><br><span class="line">result = (<span class="keyword">boolean</span>)checkLength.invoke(checkLength, <span class="string">"12345"</span>);</span><br><span class="line">assertTrue(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Framework의-ReflectionTestUtils를-활용한-Private-메서드-단위-테스트"><a href="#Spring-Framework의-ReflectionTestUtils를-활용한-Private-메서드-단위-테스트" class="headerlink" title="Spring Framework의 ReflectionTestUtils를 활용한 Private 메서드 단위 테스트"></a>Spring Framework의 ReflectionTestUtils를 활용한 Private 메서드 단위 테스트</h3><p><code>RelectionTestUtils</code> 클래스의 Static 메서드인 <code>invokeMethod()</code> 메서드를 사용하여 테스트 할 Private 메서드를 실행합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1.0.0-RELEASE"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Common common;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetVersion</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String result = ReflectionTestUtils.invokeMethod(common, <span class="string">"getVersion"</span>);</span><br><span class="line">assertEquals(<span class="string">"1.0.0-RELEASE"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Reference</strong></p><ul><li><a href="https://www.baeldung.com/spring-reflection-test-utils" rel="external nofollow noopener noreferrer" target="_blank">Spring Reflection Test Utils - Baeldung</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;단위 테스트 작성시 Private 접근자를 가진 메소드를 테스트하는 방법을 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://hyunto.github.io/categories/Programming/"/>
    
    
      <category term="Java" scheme="https://hyunto.github.io/tags/Java/"/>
    
      <category term="Spring Framework" scheme="https://hyunto.github.io/tags/Spring-Framework/"/>
    
      <category term="Unit Test" scheme="https://hyunto.github.io/tags/Unit-Test/"/>
    
      <category term="jUnit" scheme="https://hyunto.github.io/tags/jUnit/"/>
    
      <category term="Reflection" scheme="https://hyunto.github.io/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>스트림(Stream) 활용</title>
    <link href="https://hyunto.github.io/2019/02/17/java8-stream-practice/"/>
    <id>https://hyunto.github.io/2019/02/17/java8-stream-practice/</id>
    <published>2019-02-16T15:24:07.000Z</published>
    <updated>2019-08-08T14:23:01.952Z</updated>
    
    <content type="html"><![CDATA[<p>Java8 Stream 활용 방안을 정리합니다.</p><a id="more"></a><!-- TOC --><p>스트림을 활용하면 <strong>외부 반복</strong> 을 <strong>내부 반복</strong> 으로 바꿀 수 있어 좀 더 직관적인 코드를 작성할 수 있습니다. 또한 병렬로 수행할지 여부를 결정할 수 있습니다.</p><p>본문에서는 스트림 API를 활용하는 방법을 정리합니다.</p><h1 id="필터링과-슬라이싱"><a href="#필터링과-슬라이싱" class="headerlink" title="필터링과 슬라이싱"></a>필터링과 슬라이싱</h1><ul><li>filter()</li><li>distinct()</li><li>limit()</li><li>skip()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** 프레디케이트로 필터링 **</span></span><br><span class="line"><span class="comment">// 스트림 인터페이스의 filter 메서드는 Predicate를 인수로 받고,</span></span><br><span class="line"><span class="comment">// 일치하는 모든 요소를 반환한다.</span></span><br><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream()</span><br><span class="line">                                .filter(Dish::isVegetarian)</span><br><span class="line">                                .collect(toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 고유 요소 필터링 **</span></span><br><span class="line"><span class="comment">// distinct 메서드로 중복을 제거한다.</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       .distinct()</span><br><span class="line">       .forEach(System.out::println);    <span class="comment">// 2, 4 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 스트림 축소 **</span></span><br><span class="line"><span class="comment">// (정렬 여부와 상관없이)지정된 개수 이하의 크기만 반환하는 limit(n) 메서드</span></span><br><span class="line">List&lt;Dish&gt; dishes = menu.stream()</span><br><span class="line">                        .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">                        .limit(<span class="number">3</span>)</span><br><span class="line">                        .collect(toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 요소 건너뛰기 **</span></span><br><span class="line"><span class="comment">// 처음 n개 요소를 제외한 스트림을 반환하는 skip(n) 메서드</span></span><br><span class="line">List&lt;Dish&gt; dishes = menu.stream()</span><br><span class="line">                        .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">                        .skip(<span class="number">2</span>)</span><br><span class="line">                        .collect(toList());</span><br></pre></td></tr></table></figure><h1 id="매핑"><a href="#매핑" class="headerlink" title="매핑"></a>매핑</h1><ul><li>map()</li><li>flatMap() : 각 배열을 스트림이 아니라 스트림의 컨텐츠로 매핑한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** 스트림의 각 요소에 함수 적용하기 **</span></span><br><span class="line"><span class="comment">// 예제 1&gt; 메뉴의 이름으로 변환(매핑)</span></span><br><span class="line">List&lt;String&gt; dishNames = menu.stream()</span><br><span class="line">                             .map(Dish::getName)</span><br><span class="line">                             .collect(toList());</span><br><span class="line"><span class="comment">// 예제 2&gt; 단어의 길이로 변환(매핑)</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"Java8"</span>, <span class="string">"Lambdas"</span>, <span class="string">"In"</span>, <span class="string">"Action"</span>);</span><br><span class="line">List&lt;Integer&gt; wordLengths = words.stream()</span><br><span class="line">                                 .map(String::length)</span><br><span class="line">                                 .collect(toList());</span><br><span class="line"><span class="comment">// 예제 3&gt; 메뉴 이름의 글자수로 변환(매핑)</span></span><br><span class="line">List&lt;Integer&gt; dishNameLengths = menu.stream()</span><br><span class="line">                                    .map(Dish::getName)</span><br><span class="line">                                    .map(String::length)</span><br><span class="line">                                    .collect(toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 스트림 평면화 **</span></span><br><span class="line"><span class="comment">// ["Hello", "World"] --&gt; ["H", "e", "l", "o", "W", "r", "d"] 로 변환 예제</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">List&lt;String&gt; flattedDistinctedWord = words.stream()</span><br><span class="line">                                          .map(word -&gt; word.split(<span class="string">""</span>))</span><br><span class="line">                                          .flatMap(Arrays::stream)</span><br><span class="line">                                          .distinct()</span><br><span class="line">                                          .collect(Copllectors.toList());</span><br></pre></td></tr></table></figure><h1 id="검색과-매칭"><a href="#검색과-매칭" class="headerlink" title="검색과 매칭"></a>검색과 매칭</h1><ul><li>allMatch()</li><li>anyMatch()</li><li>noneMatch()</li><li>findFirst()</li><li>findAny() : 현재 스트림에서 임의의 요소를 반환. 병렬 스트림에서는 첫 번째 요소를 찾기 어렵기 때문에 제약이 적은 findAny를 사용한다.</li></ul><p>allMatch(), anyMatch(), noneMatch() 메서드는 자바의 <code>&amp;&amp;</code>, <code>||</code> 연산 처럼 활용된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** Predicate가 적어도 한 요소와 일치하는지 확인 **</span></span><br><span class="line"><span class="comment">// 메뉴 중 채식주의자 용 메뉴가 하나라도 존재하면 메세지 출력</span></span><br><span class="line"><span class="keyword">if</span> (menu.stream().anyMatch(Dish::isVegetarian)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"The menu is (somewhat) vegetarian friendly!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** Predicate가 모든 요소와 일치하는지 검사 **</span></span><br><span class="line"><span class="comment">// 모든 메뉴가 1000 칼로리 미만인지 확인</span></span><br><span class="line"><span class="keyword">boolean</span> isHealthy = menu.stream()</span><br><span class="line">                        .allMatch(d -&gt; d.getCalories() &lt; <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">boolean</span> isHealthy = menu.stream()</span><br><span class="line">                        .noneMatch(d -&gt; d.getCalories() &gt;= <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 임의의 요소 검색 **</span></span><br><span class="line"><span class="comment">// 채식 요리 선택</span></span><br><span class="line">Optional&lt;Dish&gt; dish = menu.stream()</span><br><span class="line">                          .filter(Dish::isVegetarian)</span><br><span class="line">                          .findAny()</span><br><span class="line">                          .ifPresent(d -&gt; System.out.println(d.getName()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 첫 번째 요소 검색 **</span></span><br><span class="line">List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream()</span><br><span class="line">                                                           .map(n -&gt; n * n)</span><br><span class="line">                                                           .filter(n -&gt; n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                                           .findFirst();    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h1 id="리듀싱"><a href="#리듀싱" class="headerlink" title="리듀싱"></a>리듀싱</h1><ul><li>reduce()</li></ul><p>reduce 메서드는 <strong>병렬 처리가 가능</strong>하다는 장점이 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** 요소의 합 **</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : numbers) &#123;</span><br><span class="line">    sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">int</span> sum = numbers.steam().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"><span class="keyword">int</span> sum = numbers.steam().reduce(<span class="number">0</span>, Integer:sum);    <span class="comment">// 메서드 레퍼런스 사용</span></span><br><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));    <span class="comment">// 초기값을 받지 않는 방법 (Optional 객체로 반환)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 최대값과 최소값 **</span></span><br><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">연산</th><th align="center">형식</th><th align="center">반환 형식</th><th align="center">사용된 함수형 인터페이스 형식</th><th align="center">함수 디스크립터</th></tr></thead><tbody><tr><td align="center">filter</td><td align="center">중간 연산</td><td align="center">Stream<t></t></td><td align="center">Predicate<t></t></td><td align="center">T -&gt; boolean</td></tr><tr><td align="center">distinct</td><td align="center">중간 연산<br>(상태 있는 언바운드)</td><td align="center">Stream<t></t></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">skip</td><td align="center">중간 연산<br>(상태 있는 언바운드)</td><td align="center">Stream<t></t></td><td align="center">Long</td><td align="center"></td></tr><tr><td align="center">limit</td><td align="center">중간 연산<br>(상태 있는 언바운드)</td><td align="center">Stream<t></t></td><td align="center">Long</td><td align="center"></td></tr><tr><td align="center">map</td><td align="center">중간 연산</td><td align="center">Stream<t></t></td><td align="center">Function&lt;T, R&gt;</td><td align="center">T -&gt; R</td></tr><tr><td align="center">flatMap</td><td align="center">중간 연산</td><td align="center">Stream<t></t></td><td align="center">Function&lt;T, Stream<r>&gt;</r></td><td align="center">T -&gt; Stream<r></r></td></tr><tr><td align="center">sorted</td><td align="center">중간 연산<br>(상태 있는 언바운드)</td><td align="center">Stream<t></t></td><td align="center">Comparator<t></t></td><td align="center">(T, T) -&gt; int</td></tr><tr><td align="center">anyMatch</td><td align="center">최종 연산</td><td align="center">boolean</td><td align="center">Predicate<t></t></td><td align="center">T -&gt; boolean</td></tr><tr><td align="center">noneMatch</td><td align="center">최종 연산</td><td align="center">boolean</td><td align="center">Predicate<t></t></td><td align="center">T -&gt; boolean</td></tr><tr><td align="center">allMatch</td><td align="center">최종 연산</td><td align="center">boolean</td><td align="center">Predicate<t></t></td><td align="center">T -&gt; boolean</td></tr><tr><td align="center">findAny</td><td align="center">최종 연산</td><td align="center">Optional<t></t></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">findFirst</td><td align="center">최종 연산</td><td align="center">Optional<t></t></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">forEach</td><td align="center">최종 연산</td><td align="center">void</td><td align="center">Consumer<t></t></td><td align="center">T -&gt; void</td></tr><tr><td align="center">Collect</td><td align="center">최종 연산</td><td align="center">R</td><td align="center">Collector&lt;T, A, R&gt;</td><td align="center"></td></tr><tr><td align="center">Reduce</td><td align="center">최종 연산<br>(상태 있는 언바운드)</td><td align="center">Optional<t></t></td><td align="center">BinaryOperator<t></t></td><td align="center">(T, T) -&gt; T</td></tr><tr><td align="center">count</td><td align="center">최종 연산</td><td align="center">long</td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="숫자형-스트림"><a href="#숫자형-스트림" class="headerlink" title="숫자형 스트림"></a>숫자형 스트림</h1><h2 id="기본형-특화-스트림"><a href="#기본형-특화-스트림" class="headerlink" title="기본형 특화 스트림"></a>기본형 특화 스트림</h2><p>Java8에는 박싱 비용을 줄이고 sum, max와 같이 자주 사용되는 숫자 관련 리듀싱 연산 메서드를 함께 제공하는 세 가지 기본형 특화 스트림을 제공한다.</p><ul><li>IntStream</li><li>DoubleStream</li><li>LongStream</li><li>OptionalInt</li><li>OptionalDouble</li><li>OptionalLong</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** 숫자 스트림으로 매핑 **</span></span><br><span class="line"><span class="comment">// mapToInt 메서드는 IntStream 인터페이스로 반환하며, </span></span><br><span class="line"><span class="comment">// 기본적으로 sum, min, average 등 다양한 유틸리티 메서드를 제공한다.</span></span><br><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">                   .mapToInt(Dish::getCalories)</span><br><span class="line">                   .sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// **객체 스트림으로 복원 **</span></span><br><span class="line"><span class="comment">// boxed() 메서드를 사용하여 특화 스트림을 일반 스트림으로 변환할 수 있다.</span></span><br><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional 컨테이너 클래스</span></span><br><span class="line">OptionalInt maxCalories = menu.stream()</span><br><span class="line">                              .mapToInt(Dish::getCalories)</span><br><span class="line">                              .max();</span><br><span class="line"><span class="keyword">int</span> max = maxCalories.orElse(<span class="number">1</span>);    <span class="comment">// 값이 없을 때 기본 최대값을 명시적으로 설정</span></span><br></pre></td></tr></table></figure><h2 id="숫자-범위"><a href="#숫자-범위" class="headerlink" title="숫자 범위"></a>숫자 범위</h2><p>IntStream과 LongStream은 특정 범위의 숫자를 이용하기 위한 2가지 정적 메서드를 제공한다. :</p><ul><li>range(시작값, 종료값) : 결과에 시작값, 종료값 미포함</li><li>rangeClosed(시작값, 종료값) : 결과에 시작값, 종료값 포함</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream evenNumbers = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)    <span class="comment">// 1~100</span></span><br><span class="line">                                 .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);    <span class="comment">// 짝수 필터링</span></span><br><span class="line">System.out.println(evenNumbers.count());    <span class="comment">// 50개</span></span><br></pre></td></tr></table></figure><h1 id="스트림-만들기"><a href="#스트림-만들기" class="headerlink" title="스트림 만들기"></a>스트림 만들기</h1><h2 id="값으로-스트림-만들기"><a href="#값으로-스트림-만들기" class="headerlink" title="값으로 스트림 만들기"></a>값으로 스트림 만들기</h2><ul><li>Stream.of() : 임의의 수로 인수를 받아 스트림으로 만든다.</li><li>Stream.empty() : 스트림을 비운다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8"</span>, <span class="string">"Lambdas"</span>, <span class="string">"In"</span>, <span class="string">"Action"</span>);</span><br><span class="line">stream.map(String.toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h2 id="배열로-스트림-만들기"><a href="#배열로-스트림-만들기" class="headerlink" title="배열로 스트림 만들기"></a>배열로 스트림 만들기</h2><ul><li>Arrays.stream()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();    <span class="comment">// 합계 41</span></span><br></pre></td></tr></table></figure><h2 id="파일로-스트림-만들기"><a href="#파일로-스트림-만들기" class="headerlink" title="파일로 스트림 만들기"></a>파일로 스트림 만들기</h2><p>NIO API(비블록 I/O)도 스트림 API를 활용할 수 있게 되었다.<br>java.nio.file.Files의 많은 정적 메서드가 스트림을 반환한다. (ex&gt; <code>Files.lines</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 파일에서 고유한 단어 수를 찾는 프로그램</span></span><br><span class="line"><span class="comment">// Files.lines 메서드는 주어진 파일의 행 스트림을 문자열로 반환한다.</span></span><br><span class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"data.txt"</span>), Charset.defaultCharset())) &#123;</span><br><span class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">" "</span>)))</span><br><span class="line">                       .distinct()</span><br><span class="line">                       .count();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="함수로-무한-스트림-만들기"><a href="#함수로-무한-스트림-만들기" class="headerlink" title="함수로 무한 스트림 만들기"></a>함수로 무한 스트림 만들기</h2><p>스트림 API는 함수에서 스트림을 만들 수 있는 두 개의 정적 메서드를 제공한다.<br>이전에 봤던 크기가 고정된 컬렉션과는 달리 크기가 고정되지 않은 <strong>무한 스트림(Infinite Stream)</strong> 을 만들 수 있다. (언바운드 스트림(Unbounded Stream))<br>따라서 반드시 <code>limit(n)</code> 함수와 함께 사용해야 한다.</p><ul><li>Stream.iterate()<ul><li>초기값과 람다를 인수로 받아서 새로운 값을 끊임없이 생산한다.</li><li>일반적으로 연속된 일련의 값을 만들 때 사용한다.</li></ul></li><li>Stream.generate()<ul><li>Supplier<t>를 인수로 받아서 새로운 값을 생산한다.</t></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterate</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">      .limit(<span class="number">10</span>)</span><br><span class="line">      .forEach(System.out::println);    <span class="comment">// 0, 2, 4, 6, 8, 10, 12, 14, 16, 18 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generate</span></span><br><span class="line">Stream.generate(Math::random)</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8 Stream 활용 방안을 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://hyunto.github.io/categories/Programming/"/>
    
    
      <category term="Java" scheme="https://hyunto.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://hyunto.github.io/tags/Java8/"/>
    
      <category term="Stream" scheme="https://hyunto.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>스트림(Stream) 소개</title>
    <link href="https://hyunto.github.io/2019/02/12/java8-stream-basic/"/>
    <id>https://hyunto.github.io/2019/02/12/java8-stream-basic/</id>
    <published>2019-02-11T15:13:34.000Z</published>
    <updated>2019-08-08T14:23:01.948Z</updated>
    
    <content type="html"><![CDATA[<p>Java8에서 새로 추가된 스트림의 기초를 정리합니다.</p><a id="more"></a><!-- TOC --><h1 id="스트림이란"><a href="#스트림이란" class="headerlink" title="스트림이란?"></a>스트림이란?</h1><p>스트림이란 <em>데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소</em> 로 정의할 수 있다.</p><p>스트림을 사용하면 선언형(즉, 데이터를 처리하는 임시코드 대신 질의로 표현)으로 컬렉션 데이터를 처리할 수 있다.<br>따라서 데이터 컬렉션 반복을 멋지게 처리할 수 있으며, 별도의 멀티 스레드 코드를 구현하지 않더라도 데이터를 병렬로 처리할 수 있게 된다.</p><p>다음은 저칼로리의 요리명을 반환하고, 칼로리를 기준으로 정렬하는 로직을 Java7과 Java8로 비교하는 예시이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7</span></span><br><span class="line">List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 컨테이너 역할만 하는 Gabage 변수!</span></span><br><span class="line"><span class="keyword">for</span> (Dish d : menu) &#123;</span><br><span class="line">    <span class="keyword">if</span>(d.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">        lowCaloricDishes.add(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Dish d : lowCaloricDishes) &#123;</span><br><span class="line">    lowCaloricDishesName.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java8</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collections.toList;</span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = menu.stream()</span><br><span class="line">                                        .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)    <span class="comment">// 400 칼로리 이하의 요리 선택</span></span><br><span class="line">                                        .sorted(comparing(Dish::getCalories))    <span class="comment">// 칼로리로 요리 정렬</span></span><br><span class="line">                                        .map(Dish::getName)    <span class="comment">// 요리명 추출</span></span><br><span class="line">                                        .collect(toList());    <span class="comment">// 모든 요리명을 리스트에 저장</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java8 - 병렬 처리</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collections.toList;</span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = menu.parallelStream()</span><br><span class="line">                                        .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)    <span class="comment">// 400 칼로리 이하의 요리 선택</span></span><br><span class="line">                                        .sorted(comparing(Dish::getCalories))    <span class="comment">// 칼로리로 요리 정렬</span></span><br><span class="line">                                        .map(Dish::getName)    <span class="comment">// 요리명 추출</span></span><br><span class="line">                                        .collect(toList());    <span class="comment">// 모든 요리명을 리스트에 저장</span></span><br></pre></td></tr></table></figure><p>위 예시를 통해 스트림이 소프트웨어 공학적으로 제공하는 이점을 확인할 수 있다. :</p><ul><li><strong>선언형</strong><ul><li>즉, 루프와 if 조건문 등의 제어 블록으로 어떻게 동작을 구현할지 지정하기 보다 원하는 동작의 수행을 직접적으로 지정할 수 있게 된다.</li><li>코드가 더 간결하고 가독성이 좋아진다.</li></ul></li><li><strong>조립할 수 있음</strong><ul><li>여러 빌딩 블록 연산(filter, sorted, map, collect)을 연결해서 <strong>복잡한 데이터 처리 파이프라인을 만들 수 있다.</strong></li><li>유연성이 좋아진다.</li></ul></li><li><strong>병렬화</strong><ul><li>성능이 좋아진다.</li><li>filter, sorted, map, collect 와 같은 연산은 <strong>고수준 빌딩 블록(High-Level Building Block)</strong> 으로 이루어져 있으므로 특정 스레드 모델에 제한되지 않는다. 따라서 병렬로 데이터 처리를 하면서 스레드와 락을 걱정할 필요가 없다.</li></ul></li></ul><h1 id="스트림-vs-컬렉션"><a href="#스트림-vs-컬렉션" class="headerlink" title="스트림 vs. 컬렉션"></a>스트림 vs. 컬렉션</h1><p><img src="stream-and-collection.png" alt="Stream vs. Collection"></p><h2 id="데이터를-언제-계산하는가"><a href="#데이터를-언제-계산하는가" class="headerlink" title="데이터를 언제 계산하는가?"></a>데이터를 언제 계산하는가?</h2><ul><li>컬렉션<ul><li>현재 자료구조가 포함하는 모든 값을 메모리에 저장.<br>즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되야 한다.</li><li>생산자 중심(Supplier-Driven). 즉, 팔기도 전에 창고를 가득 채우며 <strong>적극적으로 생산</strong> 한다.</li></ul></li><li>스트림<ul><li>요청할 때만 요소를 계산하는 고정된 자료구조.<br>따라서 스트림에 요소를 추가/삭제가 불가하다.</li><li>사용자가 요청하는 값만 스트림에서 추출.<br>생산자(Producer)와 소비자(Consumer) 관계.</li><li>게으르게 만들어지는 컬렉션과 같다.<br>즉, 사용자가 데이터를 요청할 때만 값을 계산한다. (요청 중심 제조(Demand-Driven Manufacturing) or 즉석 제조(Just-In-Time Manufacturing))</li></ul></li></ul><h2 id="데이터-소스를-반복-사용할-수-있는가"><a href="#데이터-소스를-반복-사용할-수-있는가" class="headerlink" title="데이터 소스를 반복 사용할 수 있는가?"></a>데이터 소스를 반복 사용할 수 있는가?</h2><ul><li>컬렉션<ul><li>데이터를 반복해서 사용 할 수 있다.</li></ul></li><li>스트림<ul><li>데이터를 단 한번만 소비할 수 있다.</li></ul></li></ul><h2 id="외부반복과-내부반복"><a href="#외부반복과-내부반복" class="headerlink" title="외부반복과 내부반복"></a>외부반복과 내부반복</h2><ul><li>컬렉션 : 외부반복 (External Iteration)</li><li>스트림 : 내부반복 (Internal Iteration)</li></ul><p>스트림은 내부반복을 통해 작업을 투명하게, 그리고 하드웨어를 활용한 병렬설 구현을 자동으로 하거나, 최적화된 다양한 순서로 처리할 수 있게 해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 컬렉션 : for-each 루프를 이용하는 외부반복</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d : menu) &#123;</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 컬렉션 : Iterator 객체를 이용하는 외부반복</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;Dish&gt; iterator = menu.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Dish d = iterator.next();</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스트림 : 내부반복</span></span><br><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">                         .map(Dish::getName)</span><br><span class="line">                         .collect(toList());</span><br></pre></td></tr></table></figure><h1 id="스트림-연산"><a href="#스트림-연산" class="headerlink" title="스트림 연산"></a>스트림 연산</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = menu.stream()    <span class="comment">// 스트림 리스트 얻기</span></span><br><span class="line">                         .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)    <span class="comment">// 중간 연산</span></span><br><span class="line">                         .map(Dish::getName)    <span class="comment">// 중간 연산</span></span><br><span class="line">                         .limit(<span class="number">3</span>)    <span class="comment">// 중간 연산</span></span><br><span class="line">                         .collect(toList());    <span class="comment">// 스트림을 리스트로 변환</span></span><br></pre></td></tr></table></figure><p>스트림 파이프라인은 빌더 패턴(Builder Pattern)과 비슷하다.<br>위 예제 코드를 보면 알 수 있듯이 스트림의 연산은 크게 2가지로 구분할 수 있다.</p><ul><li>중간 연산 (Intermediate Operation)<ul><li>filter, map, limit 는 서로 연결되여 파이프라인을 형성.</li><li>중간 연산은 다른 스트림을 반환한다. 따라서 서로 다른 여러 중간 연산을 연결/병합해서 질의를 만들 수 있다. (Loop Fusion)</li><li>중간 연산 만으로는 결과를 생성할 순 없다. (최종 연산 필요)</li><li>filter, map, limit, sorted, distinct…</li></ul></li><li>최종 연산 (Terminal Operation)<ul><li>collect 로 파이프라인을 실행한 후 종료.<br>즉, 스트림 파이프라인에서 결과를 도출하여 List, Integer, void 등의 결과로 반환한다.</li><li>forEach, count, collect…</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8에서 새로 추가된 스트림의 기초를 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://hyunto.github.io/categories/Programming/"/>
    
    
      <category term="Java" scheme="https://hyunto.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://hyunto.github.io/tags/Java8/"/>
    
      <category term="Stream" scheme="https://hyunto.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>람다 표현식 (Lambda Expression)</title>
    <link href="https://hyunto.github.io/2019/02/11/java8-lambda/"/>
    <id>https://hyunto.github.io/2019/02/11/java8-lambda/</id>
    <published>2019-02-11T14:45:50.000Z</published>
    <updated>2019-08-08T14:23:01.939Z</updated>
    
    <content type="html"><![CDATA[<p>Java8에서 새롭게 추가된 람다 표현식을 정리합니다.</p><a id="more"></a><!-- TOC --><h1 id="람다란-무엇인가"><a href="#람다란-무엇인가" class="headerlink" title="람다란 무엇인가?"></a>람다란 무엇인가?</h1><p><code>람다 표현식 (Lambda Expression)</code> 은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다.<br>람다를 사용하면 더 쉽게 <strong>동작 파라미터 형식의 코드</strong>를 구현할 수 있으며, 이에 따라 코드가 더 간결하고 유연해진다.</p><h2 id="람다의-특징"><a href="#람다의-특징" class="headerlink" title="람다의 특징"></a>람다의 특징</h2><ul><li><strong>익명</strong> : 람다는 익명 메서드 처럼 이름이 없다.</li><li><strong>함수</strong> : 람다는 메서드처럼 특정 클래스에 종속되지 않기 때문에 함수라고 부를 수 있다. 하시만 메서드처럼 “파라미터 리스트”, “바디”, “반환 형식”, “가능한 예외 리스트”를 포함한다.</li><li><strong>전달</strong> : 람다 표현식을 메서드의 인수로 저장하거나 변수로 지정할 수 있다.</li><li><strong>간결성</strong> : 익명 클래스처럼 자질구레한 코드 구현이 필요 없다.</li></ul><h2 id="람다의-구성요소"><a href="#람다의-구성요소" class="headerlink" title="람다의 구성요소"></a>람다의 구성요소</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(first.length(), second.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(strings, <span class="keyword">new</span> LengthComparator());</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line">(String first, String second) -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure><ul><li><strong>파라미터 리스트</strong> : Comparator의 compare 메서드의 파라미터 (두 개의 사과. first, second)</li><li><strong>화살표</strong> : 화살표(-&gt;)는 람다의 파라미터 리스트와 바디를 구분한다.</li><li><strong>바디</strong> : 두 사과의 무게를 비교한다. 람다의 반환값에 해당하는 표현식이다. 람다는 return이 함축되어 있기 때문에 명시적으로 사용하지 않아도 된다.</li></ul><h2 id="람다의-기본문법"><a href="#람다의-기본문법" class="headerlink" title="람다의 기본문법"></a>람다의 기본문법</h2><p><code>(parameters) -&gt; expression</code>  또는 <code>(parameters) -&gt; { statements; }</code> </p><h1 id="람다를-어디에서-어떻게-사용할까"><a href="#람다를-어디에서-어떻게-사용할까" class="headerlink" title="람다를 어디에서 어떻게 사용할까?"></a>람다를 어디에서 어떻게 사용할까?</h1><p>람다 표현식은 <code>함수형 인터페이스</code>라는 문맥에서 사용할 수 있다.<br>“함수형 인터페이스”란 <em>단 하나의 추상 메서드를 지칭하는 인터페이스</em>를 의미한다. Comparator, Runnable, Callable, Predicate 등이 있다.</p><p>람다 표현식은 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다. 따라서 전체 표현식을 함수형 인터페이스로 취급할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runnable 함수형 인터페이스 (참고용)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다 사용</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello World 1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 클래스 사용</span></span><br><span class="line">Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process(r1);<span class="comment">// 'Hello World 1' 출력</span></span><br><span class="line">process(r2);<span class="comment">// 'Hello World 2' 출력</span></span><br><span class="line">process(() -&gt; System.out.println(<span class="string">"Hello World 3"</span>));<span class="comment">// 'Hello World 3' 출력</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>함수 디스크립터 (Function Descriptor)</strong></p><ul><li>람다 표현식의 시그니처(Signature)를 가리키는 “함수형 인터페이스의 추상 메서드 시그니처”</li><li>예를 들어 Runnable 인터페이스의 유일한 추상 메서드인 run은 인수와 반환값이 없으므로 Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다. 즉, () -&gt; void 라는 표기법으로 표현할 수 있다.</li></ul></blockquote><h1 id="람다-활용-실행-어라운드-패턴"><a href="#람다-활용-실행-어라운드-패턴" class="headerlink" title="람다 활용 : 실행 어라운드 패턴"></a>람다 활용 : 실행 어라운드 패턴</h1><p>데이터베이스 연동, 파일 읽기/쓰기 등의 작업은 보통 다음과 같은 순환 패턴(Recurrent Pattern)로 이뤄진다.</p><ol><li><strong>Resource Open</strong> (초기화 / 준비 코드)</li><li>Processing (실제 처리 코드)</li><li><strong>Resource Close</strong> (정리 / 마무리 코드)</li></ol><p>Resource Open/Close와 같이 실제 처리 코드를 둘러싸는 형식의 코드를 <strong>실행 어라운드 패턴(Execute Around Pattern)</strong> 이라고 부른다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 단계 : 동작 파라미터화를 기억하라</span></span><br><span class="line"><span class="comment"> *  - 한 번에 한 줄만 읽을 수 있는 코드를 "동작 파라미터화"를 통해 다른 동작을 수행할 수 있도록 변경해 보자!</span></span><br><span class="line"><span class="comment"> *  - 즉, 아래 코드에서 "초기화 &amp; 정리" 코드만 재사용하고 "처리" 코드는 동적으로 수행하도록 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"data.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();<span class="comment">// 실제 필요한 작업을 수행</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2 단계 : 함수형 인터페이스를 이용해서 동작 전달</span></span><br><span class="line"><span class="comment"> *  - (BufferedReader -&gt; String)과 IOException 예외를 던질 수 있는 시그니처와 일치하는 </span></span><br><span class="line"><span class="comment"> *    함수형 인터페이스를 만든다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BufferedReaderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(BufferedReader b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3 단계 : 동작 실행!</span></span><br><span class="line"><span class="comment"> *   - 이제 BufferedReaderProcessor 함수형 인터페이스에 정의된 process 메서드의 </span></span><br><span class="line"><span class="comment"> *     시그니처(BufferedReader -&gt; String)와 일치하는 람다를 전달할 수 있다.</span></span><br><span class="line"><span class="comment"> *   - 람다 표현식으로 함수형 인터페이스의 추상 메서드(process) 구현체를 직접 전달하여 처리할 수 있게 된다. </span></span><br><span class="line"><span class="comment"> *     (4단계 참고)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"data.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.process(br);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4 단계 : 람다 전달</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String oneLine = processFile((BufferedReader br) -&gt; br.readLine());</span><br><span class="line">String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine());</span><br></pre></td></tr></table></figure><h1 id="자바8의-함수형-인터페이스"><a href="#자바8의-함수형-인터페이스" class="headerlink" title="자바8의 함수형 인터페이스"></a>자바8의 함수형 인터페이스</h1><p>자바8 라이브러리 설계자들은 java.util.function 패키지로 여러 가지 새로운 함수형 인터페이스를 제공한다.</p><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>Predicate<t> 인터페이스는 test라는 추상 메서드를 정의하며, test 메서드는 제네릭 형식 T의 객체를 인수로 받아 Boolean을 반환한다.<br>즉, T 형식의 객체를 사용하는 Boolean 표현식이 필요한 상황에서 Predicate 인터페이스를 사용할 수 있다.</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T s: list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(s)) &#123;</span><br><span class="line">            results.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();</span><br><span class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);</span><br></pre></td></tr></table></figure><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>Consumer<t> 인터페이스는 제네릭 형식의 T 객체를 받아서 void를 반환하는 accept 라는 추상 메서드를 정의한다.<br>T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용할 수 있다.</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T i: list) &#123;</span><br><span class="line">        c.accept(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forEach(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (Integer i) -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Function&lt;T, R&gt; 인터페이스는 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 apply라는 추상 메서드를 정의한다.<br>입력을 출력으로 매핑하는 람다를 정의할 때 활용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; f)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T s : list) &#123;</span><br><span class="line">        result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [7, 2, 6]</span></span><br><span class="line">List&lt;Integer&gt; l = map(Arrays.asList(<span class="string">"lambdas"</span>, <span class="string">"in"</span>, <span class="string">"action"</span>), (String s) -&gt; s.length());</span><br></pre></td></tr></table></figure><h2 id="기본형-특화"><a href="#기본형-특화" class="headerlink" title="기본형 특화"></a>기본형 특화</h2><p>자바는 “기본형”, “참조형” 2가지 형식이 존재하는데, 제네릭은 내부 구현상 참조형만 사용할 수 있다.</p><ul><li>기본형 (Primitive Type) : int, double, byte, char 등</li><li>참조형 (Reference Type) : Byte, Integer, Object, List 등</li></ul><p>기본형과 참조형을 혼합하여 사용할 경우 변환 과정이 필요하다. 자바에서는 이 과정이 자동으로 이뤄지며, 이를 *오토 박싱(Auto Boxing)”이라고 한다. 그러나 변환시 박싱한 값은 메모리를 더 많이 소모하며, 기본형을 가져올 때에도 메모리를 탐색하는 과정이 추가로 필요하다.</p><ul><li>박싱(Boxing) : 기본형 -&gt; 참조형</li><li>언박싱(Unboxing) : 참조형 -&gt; 기본형</li></ul><p>자바8에서는 기본형 타입을 사용할 때 오토박싱을 하지 않도록 특별한 함수형 인터페이스를 제공한다.<br>일반적으로 기본형 특화 함수형 인터페이스는 이름 앞에 DoublePredicate, IntConsumer, LongBinaryOperator, IntFunction 처럼 형식명이 붙는다.</p><h2 id="자바8의-대표적인-함수형-인터페이스"><a href="#자바8의-대표적인-함수형-인터페이스" class="headerlink" title="자바8의 대표적인 함수형 인터페이스"></a>자바8의 대표적인 함수형 인터페이스</h2><table><thead><tr><th align="center">함수형 인터페이스</th><th align="center">함수 디스크립터</th><th align="center">기본형 특화</th></tr></thead><tbody><tr><td align="center">Predicate<t></t></td><td align="center">T -&gt; boolean</td><td align="center">IntPredicate, LongPredicate, DoublePredicate</td></tr><tr><td align="center">Consumer<t></t></td><td align="center">T -&gt; void</td><td align="center">IntConsumer, LongConsumer, DoubleConsumer</td></tr><tr><td align="center">Function&lt;T, R&gt;</td><td align="center">T -&gt; R</td><td align="center">IntFunction<r>, IntToDoubleFunction, ToLongFunction…</r></td></tr><tr><td align="center">Supplier<t></t></td><td align="center">() -&gt; T</td><td align="center">BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier</td></tr><tr><td align="center">UnaryOperator<t></t></td><td align="center">T -&gt; T</td><td align="center">IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td></tr><tr><td align="center">BinaryOperator<t></t></td><td align="center">(T, T) -&gt; T</td><td align="center">IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td></tr><tr><td align="center">BiPredicate&lt;L, R&gt;</td><td align="center">(L, R) -&gt; boolean</td><td align="center"></td></tr><tr><td align="center">BiConsumer&lt;T, U&gt;</td><td align="center">(T, U) -&gt; void</td><td align="center">ObjIntConsumer<t>, ObjLongConsumer<t>, ObjDoubleConsumer<t></t></t></t></td></tr><tr><td align="center">BiFunction&lt;T, U, R&gt;</td><td align="center">(T, U) -&gt; R</td><td align="center">ToIntBiFunction&lt;T, U&gt;, ToLongBiFunction&lt;T, U&gt;, ToDoubleBiFunction&lt;T, U&gt;</td></tr></tbody></table><h1 id="메서드-레퍼런스-Method-Reference"><a href="#메서드-레퍼런스-Method-Reference" class="headerlink" title="메서드 레퍼런스 (Method Reference)"></a>메서드 레퍼런스 (Method Reference)</h1><p>메서드 레퍼런스는 <strong>특정 메서드만을 호출하는 람드 표현식의 축약형</strong> 이라고 볼 수 있다.<br>메서드 레퍼런스를 사용하면 경우에 따라 람다 표현식 보다 더 가독성이 좋으며, 메서드 명을 바로 사용하기 때문에 자연스러울 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure><h2 id="메서드-레퍼런스-유형"><a href="#메서드-레퍼런스-유형" class="headerlink" title="메서드 레퍼런스 유형"></a>메서드 레퍼런스 유형</h2><ul><li><strong>정적 메서드 레퍼런스</strong><ul><li><img src="lambda-to-method_reference-1.png" alt="람다 표현식을 메서드 레퍼런스로 바꾸는 방법"></li><li>Integer의 parseInt 메서드는 <code>Integer::parseInt</code>로 표현 가능</li></ul></li><li><strong>다양한 형식의 인스턴스 메서드 레퍼런스</strong><ul><li><img src="lambda-to-method_reference-2.png" alt="람다 표현식을 메서드 레퍼런스로 바꾸는 방법"></li><li>String의 length 메서드는 <code>String::length</code>로 표현 가능</li><li><code>(String s) -&gt; s.toUpperCase()</code> 람다 표현식을 <code>String::toUpperCase</code> 로 줄여서 사용 가능</li></ul></li><li><strong>기존 객체의 인스턴스 메서드 레퍼런스</strong><ul><li><img src="lambda-to-method_reference-3.png" alt="람다 표현식을 메서드 레퍼런스로 바꾸는 방법"></li><li>Transaction 객체를 할당받은 expensiveTransaction 지역변수가 있고, Transaction 객체에는 getValue 메서드가 있다면, <code>expensiveTransaction::getValue</code>로 표현 가능</li><li><code>() -&gt; expensiveTransaction.getValue()</code> 람다 표현식을 <code>expensiveTransaction::getValue</code> 로 줄여서 사용 가능</li></ul></li></ul><h2 id="생성자-레퍼런스"><a href="#생성자-레퍼런스" class="headerlink" title="생성자 레퍼런스"></a>생성자 레퍼런스</h2><p><code>ClassName::new</code> 처럼 클래스명과 new 키워드를 사용해서 생성자의 레퍼런스를 만들 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 인수가 없는 생성자</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; <span class="keyword">new</span> Apple();</span><br><span class="line">Apple a1 = c1.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>;</span><br><span class="line">Apple a1 = c1.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Integer 인수 1개를 갖는 생성자</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = (weight) -&gt; <span class="keyword">new</span> Apple(weight);</span><br><span class="line">Apple a2 = c2.apply(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = Apple::<span class="keyword">new</span>;</span><br><span class="line">Apple a2 = c2.apply(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String, Integer 인수 2개를 갖는 생성자</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">BiFunction&lt;String, Integer, Apple&gt; c3 = (color, weight) -&gt; <span class="keyword">new</span> Apple(color, weight);</span><br><span class="line">Apple c3 = c3.apply(<span class="string">"green"</span>, <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">BiFunction&lt;String, Integer, Apple&gt; c3 = Apple::<span class="keyword">new</span>;</span><br><span class="line">Apple c3 = c3.apply(<span class="string">"green"</span>, <span class="number">110</span>);</span><br></pre></td></tr></table></figure><h1 id="람다-메서드-레퍼런스-활용-예제"><a href="#람다-메서드-레퍼런스-활용-예제" class="headerlink" title="람다, 메서드 레퍼런스 활용 예제"></a>람다, 메서드 레퍼런스 활용 예제</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1단계 : 동작 파라미터화를 통한 코드 전달</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inventory.sort(<span class="keyword">new</span> AppleComparator());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2단계 : 익명 클래스 사용</span></span><br><span class="line">inventory.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1단계 : 람다 표현식 사용</span></span><br><span class="line">inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line"><span class="comment">// 3-2단계 : 람다 표현식 코드 줄이기 (자바 컴파일러가 람다의 파라미터 형식을 추론)</span></span><br><span class="line">inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line"><span class="comment">// 3-3단계 : 정적 메서드 comparing 활용</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line">inventory.sort(comparing((a) -&gt; a.getWeight()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4단계 : 메서드 레퍼런스 사용</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8에서 새롭게 추가된 람다 표현식을 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://hyunto.github.io/categories/Programming/"/>
    
    
      <category term="Java" scheme="https://hyunto.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://hyunto.github.io/tags/Java8/"/>
    
      <category term="Lambda" scheme="https://hyunto.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0 - 기본개념 및 Authorization Grant</title>
    <link href="https://hyunto.github.io/2019/01/15/introduction-to-oauth2.0/"/>
    <id>https://hyunto.github.io/2019/01/15/introduction-to-oauth2.0/</id>
    <published>2019-01-15T04:07:26.000Z</published>
    <updated>2019-08-08T14:23:01.943Z</updated>
    
    <content type="html"><![CDATA[<p>최근 OAuth 2.0에 대해 공부하면서 다양한 Grant 종류가 존재함을 알게 되었습니다.<br>기본 개념과 Grant 종류에 대해 잘 정리되어 OAuth 2.0 이해에 도움됬던 사이트들의 내용을 정리합니다.</p><a id="more"></a><!-- TOC --><h1 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h1><p>OAuth2는 사용자가 HTTP 서비스 상에서 어플리케이션의 제한된 접근을 허용하기 위한 인가(Authorization) 프레임워크 입니다.<br>인증은 사용자 계정을 소유한 서비스로 위임하고, 사용자 계정에게 Third-Party 어플리케이션 접근 권한을 부여합니다.<br>OAuth2는 웹, 데스크톱 어플리케이션, 모바일 디바이스 등을 위한 인가 플로우(Flow)를 제공합니다.</p><p><a href="http://tools.ietf.org/html/rfc6749" rel="external nofollow noopener noreferrer" target="_blank">OAuth 2.0 Specification</a> 은 Access Token을 발급 받으려는 클라이언트에게 다양한 Grant(“Method”)를 제공하는 유연한 인가 프레임워크 입니다.<br>Access Token은 API Endpoint로의 요청을 인증하는데 사용되며, 클라이언트의 데이터에 접근하기 위한 권한을 표현합니다.</p><p>명세서에서는 Access Token을 발급하기 위한 5가지 Grant 타입을 정의합니다. :</p><ul><li>Authorization Code Grant<ul><li>서버-사이드 어플리케이션에서 사용</li></ul></li><li>Implicit Grant<ul><li>모바일 앱 또는 웹 어플리케이션 (사용자의 장비에서 동작하는 어플리케이션)에서 사용</li></ul></li><li>Resource Owner Credentials Grant<ul><li>클라이언트와 OAuth2 프로바이더와 동일한 도메인, 같은 서비스와 같이 서로 신뢰할 수 있는 어플리케이션일 때 사용</li></ul></li><li>Client Credentials Grant<ul><li>Application API 접근시 사용 (예를 들어 Microservice Architecture에서 각 API 서비스간의 인가)</li></ul></li><li>Refresh Token Grant<ul><li>Access Token 사용기간 만료시 Resource Owner가 매번 다시 인증, 인가 절차를 수행하지 않고 갱신함으로써 더 나은 사용자 경험을 제공하기 위해 사용</li></ul></li></ul><h1 id="OAuth-역할"><a href="#OAuth-역할" class="headerlink" title="OAuth 역할"></a>OAuth 역할</h1><ul><li>Resource Owner : User<ul><li>Resource Owner는 어플리케이션이 사용자 계정(보호된 자원)에 접근하도록 인가를 부여/승인하는 사용자 입니다.</li><li>사용자 계정으로의 어플리케이션의 접근 권한은 “Scope”라는 것으로 제한됩니다.</li></ul></li><li>Resource / Authorization Server : API Server<ul><li>Resource Server는 보호된 사용자 계정을 호스팅하고, Access Token을 기반으로 보호된 자원으로의 요청을 승인, 응답합니다.</li><li>Authorization Server는 사용자의 ID를 확인한 다음 어플리케이션에게 Access Token을 발급합니다.</li><li>보통 Resource Server와 Authorization Server의 조합을 OAuth 2.0 Provider라고 합니다.<br>Resource Server는 Authorization Server와 하나의 서비스로 구현되기도 합니다. </li></ul></li><li>Client : Application<ul><li>사용자의 계정에 접근을 하려는 어플리케이션</li><li>클라이언트는 먼저 사용자에게 인가받아야 하며, 이때 API 서버에 의해 승인받아야 합니다.</li></ul></li></ul><h1 id="추상적인-Protocol-Flow"><a href="#추상적인-Protocol-Flow" class="headerlink" title="추상적인 Protocol Flow"></a>추상적인 Protocol Flow</h1><p><img src="oauth2-abstract-protocol-flow.jpg" alt="Abstract Protocol Flow"></p><p>각 OAuth 역할들이 일반적으로 어떻게 서로 상호작용하는지 추상적으로 설명합니다. :</p><ol><li>Application(Client)는 보호된 자원으로 접근을 위해 사용자(Resource Owner)에게 인가 승인을 요청합니다.</li><li>사용자(Resource Owner)가 인가 요청을 승인하면 Application(Client)는 승인 허가를 받습니다.</li><li>Application(Client)는 Authorization Server(API)로 Access Token 발급을 요청합니다.<br>이때 인증을 위한 ID와 제공받을 권한을 함께 전달합니다.</li><li>인증 정보와 제공할 권한 정보가 유효하면 Authorization Server(API)는 Application(Client)에게 Access Token을 발급합니다.<br>이로써 인가(Authorization) 프로세스가 완료됩니다.</li><li>Application(Client)는 Resource Server(API)에게 인증을 위한 Access Token을 전달하면서 필요한 자원으로의 접근을 요청합니다.</li><li>Resource Server(API)는 Access Token 정보가 유효하면 해당 자원으로의 접근을 허용, 제공 합니다.</li></ol><h1 id="Application-등록"><a href="#Application-등록" class="headerlink" title="Application 등록"></a>Application 등록</h1><p>어플리케이션이 OAuth를 사용하기 전에 서비스 등록을 해야 합니다.<br>보통 Developer / API 웹 사이트에서 등록할 수 있습니다. 이때 다음 정보를 제공해야 합니다.</p><ul><li>Application Name</li><li>Application Website</li><li>Redirect URL 또는 Callback URL<ul><li>사용자가 어플리케이션을 승인 또는 거절한 후 사용자를 리다이렉트 할 URL</li><li>Authorization Code 또는 Access Token을 다루는 어플리케이션의 일부</li></ul></li></ul><h1 id="Authorization-Grant-Type"><a href="#Authorization-Grant-Type" class="headerlink" title="Authorization Grant Type"></a>Authorization Grant Type</h1><h2 id="Authorization-Code-Grant"><a href="#Authorization-Code-Grant" class="headerlink" title="Authorization Code Grant"></a>Authorization Code Grant</h2><p>Authorization Code Grant 는 소스 코드가 공개적으로 노출되지 않고, 클라이언트 Secret 값을 안전하게 유지할 수 있는 서버-사이드 어플리케이션에 최적화되어 있기 때문에 가장 일반적으로 사용되는 방식입니다.</p><p>이 방식은 “Redirection-based Flow” 입니다.<br>즉, 어플리케이션은 User-Agent (i.e. 사용자의 웹 브라우저)와 상호작용 할 수 있어야 하고, User-Agent를 통해 라우팅되는 API Authorization Code를 받을 수 있어야 합니다.</p><p><img src="authorization-code-flow.jpg" alt="Authorization Code Grant Flow"></p><h3 id="Step-1-Authorization-Code-Link"><a href="#Step-1-Authorization-Code-Link" class="headerlink" title="Step 1. Authorization Code Link"></a>Step 1. Authorization Code Link</h3><p>먼저 Application(Client)는 OAuth 2.0 프로바이더에게 다음과 같이 Authorization Code Link를 제공합니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/provider.oauth2.com/oauth</span><span class="regexp">/authorize?response_type=code&amp;client_id=$&#123;CLIENT_ID&#125;&amp;redirect_uri=$&#123;CALLBACK_URL&#125;&amp;scope=read</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://oauth2-provider.coml/oauth/authorize" rel="external nofollow noopener noreferrer" target="_blank">https://oauth2-provider.coml/oauth/authorize</a> : API Authorization Endpoint</li><li>client_id : Application의 Client ID. 보통 Facebook, Google과 같은 API 서비스 제공자가 등록된 어플리케이션을 구분하기 위해 제공하는 ID 값을 의미합니다.</li><li>redirect_uri : Authorization Code를 승인 받은 후 User-Agent가 리다이렉트 될 URI</li><li>response_type : Application(Client)가 사용을 원하는 Grant 타입을 지정하여 전달합니다. Authorization Code Grant와 Implicit Grant 방식에서만 사용됩니다.<ul><li>code : Authorization Code</li><li>token : Implicit Grant</li></ul></li><li>scope : Application(Client)이 요청하는 액세스 수준을 지정합니다.</li></ul><h3 id="Step-2-User-Authorizes-Application"><a href="#Step-2-User-Authorizes-Application" class="headerlink" title="Step 2. User Authorizes Application"></a>Step 2. User Authorizes Application</h3><p>만약 사용자가 접근 / 사용하려는 서비스에 로그인 되어 있지 않다면 우선 로그인 페이지로 이동합니다.<br>로그인 후에 “해당 서비스의 특정 기능을 어떤 권한을 갖고 사용할지 허용 또는 거부하는 페이지(Authorization Page)”로 이동합니다.</p><p>아래의 스크린샷은 DigitalOcean의 Authorization Page인데, “Thedropletbook App”이 “<a href="mailto:manicas@digitalocean.com" rel="external nofollow noopener noreferrer" target="_blank">manicas@digitalocean.com</a>“ 사용자에게 “Read” 권한 허용을 요청하는 것을 볼 수 있습니다.<br><img src="authorization-page.jpg" alt="Authorization Page"></p><h3 id="Step-3-Application-Receives-Authorization-Code"><a href="#Step-3-Application-Receives-Authorization-Code" class="headerlink" title="Step 3. Application Receives Authorization Code"></a>Step 3. Application Receives Authorization Code</h3><p>사용자가 권한 사용을 허가(승인 버튼 클릭)하면 Authorization Server는 Redirect URL (Callback URL)로 Authorization Code 또는 Access Token을 포함하여 리다이렉트 합니다.<br>Redirect URL은 각 Developer / API 사이트에서 어플리케이션 등록 중 지정한 값 입니다.</p><p>어플리케이션이 “dropletbook.com”이라고 가정할 때, 리다이렉트는 다음과 같이 보일 것 입니다. :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/dropletbook.com/callback</span>?code=AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure><p>Redirect URL에는 민감한 정보가 포함되어 있으므로, 서비스가 사용자를 임의의 위치로 리다이렉트 하지 않는 것이 중요합니다.<br>따라서 사용자가 올바른 위치로 리다이렉트 되는 것을 보장하기 위해 각  Developer / API 사이트에서 어플리케이션 등록시 한개 이상의 Redirect URL을 등록하도록 유도합니다.</p><h3 id="Step-4-Application-Requests-Access-Token"><a href="#Step-4-Application-Requests-Access-Token" class="headerlink" title="Step 4. Application Requests Access Token"></a>Step 4. Application Requests Access Token</h3><p>Application(Client)는 Access Token을 발급받기 위해 <strong>Authorization Server로 부터 받은 Authorization Code 값</strong>, <strong>Client Secret 값이 포함된 상세한 인증 정보</strong>를 Authorization Server로 전달합니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/provider.oauth2.com/oauth</span><span class="regexp">/token?client_id=$&#123;CLIENT_ID&#125;&amp;client_secret=$&#123;CLIENT_SECRET&#125;&amp;grant_type=authorization_code&amp;code=$&#123;AUTHORIZATION_CODE&#125;&amp;redirect_uri=$&#123;CALLBACK_URL&#125;</span></span><br></pre></td></tr></table></figure><ul><li>client_id</li><li>client_secret</li><li>grant_type</li><li>code</li><li>redirect_uri</li></ul><h3 id="Step-5-Application-Receives-Access-Token"><a href="#Step-5-Application-Receives-Access-Token" class="headerlink" title="Step 5. Application Receives Access Token"></a>Step 5. Application Receives Access Token</h3><p>만약 인가 정보가 올바르다면 Authorization Server는 Application(Client)에게 Access Token (경우에 따라 Refresh Token이 될 수 있다)을 포함한 응답을 보냅니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"$&#123;ACCESS_TOKEN&#125;"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">2592000</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"$&#123;REFRESH_TOKEN&#125;"</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"read"</span>,</span><br><span class="line">    <span class="attr">"uid"</span>: <span class="number">100101</span>,</span><br><span class="line">    <span class="attr">"info"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Mark E. Mark"</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"mark@thefunkybunch.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Application(Client)는 보호된 리소스 사용을 허가받았습니다!<br>Access Token이 만료되거나 폐지될 때까지 Access Token을 사용하여 서비스 API의 보호된 리소스를 제한된 권한 내에서 사용할 수 있습니다.</p><h2 id="Implicit-Grant"><a href="#Implicit-Grant" class="headerlink" title="Implicit Grant"></a>Implicit Grant</h2><p>Implicit Grant 타입은 Client Secret 값의 기밀성을 보자하지 못하는 Mobile App.과 Web App.에서 사용됩니다.<br>Authorization Code Grant 타입과 마찬가지로 이 방식 역시 “Redirection-Based Flow” 입니다. 그러나 Application(Client)에게  Access Token을 전달하기 위해 먼저 Access Token을 User-Agent에게 발급합니다. 따라서 Access Token이 사용자 및 사용자 장비의 다른 어플리케이션에 노출될 수 있습니다.<br>또한 Implicit Grant 타입은 Application(Client)의 ID를 인증하지 않으며, 이를 위해 (Application 등록 시 설정한) Redirect URL에 의존하게 됩니다.</p><p>이 Grant 타입은 Refresh Token을 지원하지 않습니다.</p><p>Implicit Grant 타입의 프로세스를 간략히 설명하면 다음과 같습니다. : </p><ol><li>사용자(Resource Owner)는 Application(Client)을 승인하도록 요청받습니다.</li><li>Authorization Server는 User-Agent에게 Access Token을 전달합니다.</li><li>User-Agent는 Application(Client)에게 Access Token을 전달합니다.</li></ol><p><img src="implicit-flow.jpg" alt="Implicit Grant Flow"></p><h3 id="Step-1-Implicit-Authorization-Link"><a href="#Step-1-Implicit-Authorization-Link" class="headerlink" title="Step 1. Implicit Authorization Link"></a>Step 1. Implicit Authorization Link</h3><p>Implicit Grant 타입에서 사용자(Resource Owner)는 Authorization Server로부터 Access Token을 요청할 Autorization Link를 제공 받습니다. 이 링크는 response_type 값으로 Code 대신 Token을 요청하는 점을 제외하곤 Authorization Code Grant의 링크와 같습니다.</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">https</span>://provider.oauth2.com/oauth/authorize?response_<span class="keyword">type</span>=token&amp;client_id=$&#123;<span class="type">CLIENT_ID</span>&#125;&amp;redirect_uri=$&#123;<span class="type">CALLBACK_URL</span>&#125;&amp;scope=$&#123;<span class="type">SCOPE</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-User-Authorizes-Application-1"><a href="#Step-2-User-Authorizes-Application-1" class="headerlink" title="Step 2. User Authorizes Application"></a>Step 2. User Authorizes Application</h3><p>사용자가 위 링크를 클릭하면 먼저 해당 서비스로 로그인을 하고, “해당 서비스의 특정 기능을 어떤 권한을 갖고 사용할지 허용 또는 거부하는 페이지(Authorization Page)”로 이동합니다.</p><p>아래 스크린샷에서 “Thedropleetbook App”은 “<a href="mailto:manicas@digitalocean.com" rel="external nofollow noopener noreferrer" target="_blank">manicas@digitalocean.com</a>“ 사용자에게 READ 권한 허용을 요청하는 것을 볼 수 있습니다.</p><p><img src="authorization-page.jpg" alt="Authorization Page"></p><h3 id="Step-3-User-Agent-Receives-Access-Token-with-Redirect-URI"><a href="#Step-3-User-Agent-Receives-Access-Token-with-Redirect-URI" class="headerlink" title="Step 3. User-Agent Receives Access Token with Redirect URI"></a>Step 3. User-Agent Receives Access Token with Redirect URI</h3><p>사용자가 권한 사용을 허가(승인 버튼 클릭)하면 Authorization Server는 앞서 제공된 Redirection URI를 사용하여 User-Agent를 다시 Application(Client)로 리다이렉트 합니다.<br>이때 Redirection URI에는 URI Fragment로 Access Token이 포함됩니다. 또한 state, token_type, expires_in 파라미터도 함께 전달됩니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/dropletbook.com/callback</span><span class="comment">#access_token=$&#123;ACCESS_TOKEN&#125;&amp;token_type=bearer&amp;state=xyz&amp;expires_in=119</span></span><br></pre></td></tr></table></figure><h3 id="Step-4-User-Agent-Follows-the-Redirect-URI"><a href="#Step-4-User-Agent-Follows-the-Redirect-URI" class="headerlink" title="Step 4. User-Agent Follows the Redirect URI"></a>Step 4. User-Agent Follows the Redirect URI</h3><p>User-Agent는 Access Token을 가진채로 리다이렉트 지시를 따라갑니다.</p><h3 id="Step-5-Application-Sends-Access-Token-Extraction-Script"><a href="#Step-5-Application-Sends-Access-Token-Extraction-Script" class="headerlink" title="Step 5. Application Sends Access Token Extraction Script"></a>Step 5. Application Sends Access Token Extraction Script</h3><p>Application(Client)는 User-Agent가 유지한 전체 Redirect URI에서 Access Token을 추출할 수 있는 스크립트가 포함된 웹 페이지(보통 Javascript와 같은 Embedded Script가 포함된 HTML 페이지입니다.)를 응답합니다.</p><p>Redirect URI로 부터 Access Token을 추출하는 Javascript 소스코드 예제 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Facebook에서 사용자의 친구 정보를 가져오는 스크립트 */</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">window</span>.location.hash;</span><br><span class="line">    <span class="keyword">var</span> res = getResponse(fragment);</span><br><span class="line">    <span class="built_in">window</span>.location.hash = <span class="string">"_#"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res.hasError()) &#123;</span><br><span class="line">        $(<span class="string">"&lt;div&gt;Error trying to obtain user's authorization!&lt;/div&gt;"</span>).insertBefore(<span class="string">'#friends'</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getFriends(res[<span class="string">'access_token'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">friends</span>) </span>&#123;</span><br><span class="line">$(friends).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, friend</span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#friends'</span>).find(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + friend.name + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResponse</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> attributes = fragment.slice(<span class="number">1</span>).split(<span class="string">'&amp;'</span>);</span><br><span class="line"><span class="keyword">var</span> response = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">$(attributes).each(<span class="function"><span class="keyword">function</span>(<span class="params">idx, attr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> keyValue = attr.split(<span class="string">'='</span>);</span><br><span class="line">response[keyValue[<span class="number">0</span>]] = keyValue[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">response.hasError = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !response[<span class="string">'access_token'</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFriends</span>(<span class="params">accessToken, callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> baseUrl = <span class="string">'https://graph.facebook.com/v2.9/'</span>;</span><br><span class="line"><span class="keyword">var</span> endpoint = <span class="string">'me/friends'</span>;</span><br><span class="line"><span class="keyword">var</span> url = baseUrl + endpoint;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: url,</span><br><span class="line">beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Authorization"</span>, <span class="string">"bearer "</span> + accessToken);</span><br><span class="line">&#125;,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> friends = result.data;</span><br><span class="line">callback(friends);</span><br><span class="line">&#125;,</span><br><span class="line">error: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(textStatus);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-6-Access-Token-Passed-to-Application"><a href="#Step-6-Access-Token-Passed-to-Application" class="headerlink" title="Step 6. Access Token Passed to Application"></a>Step 6. Access Token Passed to Application</h3><p>User-Agent는 Application(Client) 제공된 스크립트를 실행하고, 추출된 Access Token을 Application(Client)에게 전달합니다.</p><p>이제 Application(Client)는 보호된 리소스 사용을 허가받았습니다!<br>Access Token이 만료되거나 폐지될 때까지 Access Token을 사용하여 서비스 API의 보호된 리소스를 제한된 권한 내에서 사용할 수 있습니다.</p><h2 id="Resource-Owner-Password-Credentials-Grant"><a href="#Resource-Owner-Password-Credentials-Grant" class="headerlink" title="Resource Owner Password Credentials Grant"></a>Resource Owner Password Credentials Grant</h2><p>Application(Client)는 Resource Owner의 Password Credential 정보(Username, Password)만을 사용하여 Access Token 발급을 요청합니다.</p><p>Resource Owner Password Credentials의 동작 방식은 다음과 같습니다. :</p><ol><li>사용자(Resource Owner)는 인증 정보(Username, Password)를 Application(Client)에게 직접 전달합니다.</li><li>Application(Client)는 앞서 받은 인증 정보를 Authorization Server로 전송하여 Access Token 발급을 요청합니다.</li><li>Authorization Server는 클라이언트를 인증하고, Resource Owner Credentials을 검증한 후에 Access Token을 발급합니다.</li></ol><p>Application(Client)과 OAuth 2.0 프로바이더가 같은 도메인/솔루션 내에 존재(First-Party)하여 서로 신뢰할 수 있는 경우 이 Grant 타입을 사용합니다.<br>단, Application(Client)는 사용자의 인증정보(Username, Password)를 별도로 보관하지 않아야 합니다.</p><p>Access Token 발급 요청 URL 예시 :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">"https://provider.oauth2.com/oauth/token"</span> --user $&#123;CLIENT_ID&#125;<span class="symbol">:</span>$&#123;CLIENT_SECRET&#125; -H <span class="string">"accept: application/json"</span> -H <span class="string">"content-type: application/x-www-formurlencoded"</span> -d <span class="string">"grant_type=password&amp;username=$&#123;USERNAME&#125;&amp;password=$&#123;PASSWORD&#125;&amp;scope=$&#123;SCOPE&#125;"</span></span><br></pre></td></tr></table></figure><p>Access Token 발급 요청 예시 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>Access Token 발급 응답 예시 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">    "token_type":"example",</span><br><span class="line">    "expires_in":3600,</span><br><span class="line">    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">    "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Client-Credentials-Grant"><a href="#Client-Credentials-Grant" class="headerlink" title="Client Credentials Grant"></a>Client Credentials Grant</h2><p>Application(Client)는 오직 Client Credential 정보(Client ID, Client Secret)만을 사용하여 Access Token 발급을 요청합니다.</p><p>이 Grant 타입은 Resource Owner에게서 권한을 위임 받아 제한된 리소스에 접근하는 것이 아니라 <strong>자신의 목적을 위해 어플리케이션을 사용하는 것</strong> 입니다.<br>Refresh Token을 사용하면 쉽게 Access Token을 갱신하여 사용할 수 있고, 동적으로 등록하는 과정이 쉬우며, 서비스 통합 시 모든 과정을 자동화 할 수 있기 때문에 <strong>마이크로서비스 아키텍처</strong>에서 채택되고 있습니다.</p><p>Access Token 발급 요청 URL 예시 : </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">"https://provider.oauth2.com/oauth/token"</span> --user $&#123;CLIENT_ID&#125;<span class="symbol">:</span>$&#123;CLIERNT_SECRET&#125; -d <span class="string">"grant_type=client_credentials&amp;scope=$&#123;SCOPE&#125;"</span></span><br></pre></td></tr></table></figure><p>Access Token 발급 요청 예시 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>Access Token 발급 응답 예시 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">    "token_type":"example",</span><br><span class="line">    "expires_in":3600,</span><br><span class="line">    "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Refresh-Token-Grant"><a href="#Refresh-Token-Grant" class="headerlink" title="Refresh Token Grant"></a>Refresh Token Grant</h2><p>만약 사용기간이 만료된 Access Token을 사용해 제한된 리소스 접근을 시도하면 “Invalid Token Error” 에러 메세지를 보게 됩니다.<br>Access Token 발급시 Refresh Token 값을 함께 받았다면 이를 사용해 새로운 Access Token 발급 요청을 할 수 있습니다.<br>따라서 Third-Party 어플리케이션은 사용자(Resource Owner)가 로그인 상태가 아니더라도 Refresh Token을 통해 새로운 Access Token을 발급받아 필요한 리소스에 접근할 수 있게 됩니다.<br>단, Refresh Token은 Authorization Code Grant 타입과 Resource Owner Password Credentials Grant 타입에서만 사용할 수 있습니다.</p><h1 id="Access-Token-사용법"><a href="#Access-Token-사용법" class="headerlink" title="Access Token 사용법"></a>Access Token 사용법</h1><p>일단 Application(Client)가 Access Token을 발급받고 나면 사용기간이 만료되거나 폐기되기 전까지 API를 통해 제한된 권한 내에서 보호된 리소스로 접근할 수 있습니다.</p><p>다음은 발급받은 Access Token을 사용하여 API 서버로 접근하는 예시입니다. :</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">curl</span> -X POST <span class="string">"https://example.server.com/api/<span class="variable">$&#123;OBJECT&#125;</span>"</span> -H <span class="string">"Authorization: Bearer <span class="variable">$&#123;ACCESS_TOKEN&#125;</span>"</span></span><br></pre></td></tr></table></figure><h1 id="그러면-나는-어떤-Grant-타입을-선택해야-할까"><a href="#그러면-나는-어떤-Grant-타입을-선택해야-할까" class="headerlink" title="그러면 나는 어떤 Grant 타입을 선택해야 할까?"></a>그러면 나는 어떤 Grant 타입을 선택해야 할까?</h1><p>연동하려는 서비스가 First-Party 또는 Third-Party 인지, Web App. 또는 Native App. 또는 User-Agent 기반 App. 인지에 따라 OAuth 2.0 Authorization Grant 타입을 결정할 수 있습니다.</p><!-- ![Which OAuth 2.0 Grant should I use?](which-oauth2.0-grant-should-i-use.jpg) --><p><img src="which-oauth2-grant-should-i-use.png" alt="Which OAuth 2.0 grant shoul I use?"></p><ul><li>Web Application<ul><li>A web application is a confidential client running on a web server.  Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner.  The client credentials as well as any access  token issued to the client are stored on the web server and are not exposed to or accessible by the resource owner.</li></ul></li><li>User-Agent 기반 Application<ul><li>A user-agent-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent (e.g., web browser) on the device used by the resource owner.  Protocol data and credentials are easily accessible (and often visible) to the resource owner.  Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization.</li></ul></li><li>Native Application<ul><li>A native application is a public client installed and executed on the device used by the resource owner.  Protocol data and credentials are accessible to the resource owner.  It is assumed that any client authentication credentials included in the application can be extracted.  On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive an acceptable level of protection.  At a minimum, these credentials are protected from hostile servers with which the application may interact.  On some platforms, these credentials might be protected from other applications residing on the same device.</li></ul></li></ul><blockquote><p><strong>Reference</strong></p><ul><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" rel="external nofollow noopener noreferrer" target="_blank">An Introduction to OAuth 2, DigitalOcean</a></li><li><a href="https://alexbilbie.com/guide-to-oauth-2-grants/" rel="external nofollow noopener noreferrer" target="_blank">A Guide To OAuth 2.0 Grants, Alex Bilbie Blog</a></li><li><a href="https://tools.ietf.org/html/rfc6749#section-3.3" rel="external nofollow noopener noreferrer" target="_blank">RFC 6749 - The OAuth 2.0 Authorization Framework</a></li><li><a href="https://www.oauth.com/" rel="external nofollow noopener noreferrer" target="_blank">OAuth.com</a></li><li><a href="https://auth0.com/docs/api-auth/which-oauth-flow-to-use" rel="external nofollow noopener noreferrer" target="_blank">Auth0 - Which OAuth 2.0 Grant should I use?</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근 OAuth 2.0에 대해 공부하면서 다양한 Grant 종류가 존재함을 알게 되었습니다.&lt;br&gt;기본 개념과 Grant 종류에 대해 잘 정리되어 OAuth 2.0 이해에 도움됬던 사이트들의 내용을 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://hyunto.github.io/categories/Programming/"/>
    
    
      <category term="OAuth 2.0" scheme="https://hyunto.github.io/tags/OAuth-2-0/"/>
    
  </entry>
  
  <entry>
    <title>git-secret</title>
    <link href="https://hyunto.github.io/2018/12/11/git-secret/"/>
    <id>https://hyunto.github.io/2018/12/11/git-secret/</id>
    <published>2018-12-11T03:28:08.000Z</published>
    <updated>2019-08-08T14:23:01.943Z</updated>
    
    <content type="html"><![CDATA[<p>비밀번호, Secret Key 값과 같이 보호되야 하는 데이터가 포함된 파일을 그냥 Git Commit &amp; Push 하면 개인적인 데이터가 노출되는 문제점이 발생합니다.</p><p><code>git-secret</code> 을 사용하면 개인적인 데이터가 포함된 파일을 암호화 한 후에 Git 저장소에 저장함으로써 문제점을 해결할 수 있습니다.</p><a id="more"></a><h1 id="git-secret-이란"><a href="#git-secret-이란" class="headerlink" title="git-secret 이란?"></a>git-secret 이란?</h1><p><code>git-secret</code> 은 Git 저장소에 개인적인 데이터를 <code>gpg</code> 를 기반으로 암호화하여 저장하는 Bash Tool 입니다.<br>즉, 암호화 대상 파일은 Public Key로 암호화하고, 복호화는 Private Key를 소유한 사용자만 할 수 있습니다.</p><p>이를 통해 실수로 비밀번호, Secret Key와 같이 노출되면 안되는 데이터를 그대로 Git 저장소에 업로드하는 실수를 막을 수 있습니다.</p><h1 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h1><p><code>git-secret</code> 의 기본적인 사용법은 다음과 같습니다. :</p><ol><li>gpg RSA key-pair 를 먼저 생성해야 합니다.<br>RSA key-pair 는 E-Mail 주소로 증명되는 Public / Private Key 입니다.</li><li>git-secret을 사용할 저장소에서 <code>git-secret init</code> 명령어로 초기화 합니다.<br>이때 <code>.gitsecret/</code> 디렉토리가 생성됩니다. 이 디렉토리가 .gitignore 에 의해 제외되지 않도록 해야 합니다.</li><li>첫 번째 사용자를 추가합니다. : <code>git secret tell your@gpg.email</code></li><li>git-secret으로 보호할 파일을 추가합니다. : <code>git-secret add &lt;filenames...&gt;</code><br>이때 추가할 파일은 <code>.gitignore</code> 를 사용하여 무시하도록 설정해야 합니다.</li><li>보호할 파일을 암호화 합니다. : <code>git-secret hide</code><br>이제 암호화된 파일을 Commit &amp; Push 하더라도 안전하게 보관할 수 있습니다.<br><strong>단, 반드시 매 Commit 전에 반드시 <code>git-secret hide</code> 명령어를 실행하여 변경된 사항이 반영되도록 해야 합니다.</strong></li><li>보호된 파일을 복호화 합니다. 이때 비밀번호 입력을 요구합니다. : <code>git-secret reveal</code></li></ol><p>다른 사용자를 추가하는 방법은 다음과 같습니다. :</p><ol><li>gpg Public Key를 받습니다. (Private Key는 필요 없습니다.)</li><li>당신의 gpg에 전달 받은 Public Key를 Import 합니다. : <code>gpg --import KEY_NAME</code></li><li>git-secret에 사용자를 추가합니다. : <code>git-secret tell person@email.id</code></li><li>파일들을 다시 암호화 합니다.<br>이제 새로 추가된 사용자들은 그들의 Private Key로 복호화 할 수 있습니다.</li></ol><h1 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h1><h2 id="설치-전-요구사항"><a href="#설치-전-요구사항" class="headerlink" title="설치 전 요구사항"></a>설치 전 요구사항</h2><ul><li>git 2.7.0 버전 이상</li><li>gpg (GnuPG) 1.4.20 버전 이상</li><li>운영체제 : Mac OS X &gt;= 10.9, Ubuntu &gt;- 14.04, Debian &gt;= 8.3, Fedora</li></ul><h2 id="설치-방법"><a href="#설치-방법" class="headerlink" title="설치 방법"></a>설치 방법</h2><p>여기선 Mac OS X 환경에서 설치하는 과정만 포함합니다.<br>각 OS 별 설치 방법은 <a href="http://git-secret.io/installation" rel="external nofollow noopener noreferrer" target="_blank">git-secret Installation</a> 문서를 참고 바랍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br><span class="line">$ git --version</span><br><span class="line">git version 2.20.0</span><br><span class="line"></span><br><span class="line">$ brew install gnupg</span><br><span class="line">$ gpg --<span class="built_in">help</span></span><br><span class="line">gpg (GnuPG) 2.2.11</span><br><span class="line">...하단 생략...</span><br><span class="line"></span><br><span class="line">$ brew install git-secret</span><br><span class="line">0.2.4</span><br></pre></td></tr></table></figure><h1 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git-secret usage</span><br><span class="line"></span><br><span class="line">usage: git secret [--version] [add|cat|changes|clean|hide|init|killperson|list|remove|reveal|tell|usage|whoknows]</span><br><span class="line"> <span class="string">'git secret --version'</span> will show version and <span class="built_in">exit</span></span><br><span class="line"> </span><br><span class="line">See <span class="string">'git secret [command] -h'</span> <span class="keyword">for</span> more information on each <span class="built_in">command</span> below</span><br><span class="line"> add [filename.txt] - adds file to be hidden. Also add this file to .gitignore</span><br><span class="line"> cat [filename.txt] - cats the decrypted contents of the named file to stdout</span><br><span class="line"> changes [filename.secret] - indicates <span class="keyword">if</span> the file has changed since checkin</span><br><span class="line"> clean - deletes encrypted files</span><br><span class="line"> hide - encrypts (or re-encrypts) the files to be hidden</span><br><span class="line"> init - creates the .gitsecret directory and contents needed <span class="keyword">for</span> git-secret</span><br><span class="line"> killperson [emails] - the reverse of <span class="string">'tell'</span>, removes access <span class="keyword">for</span> the named user</span><br><span class="line"> list - shows files to be hidden/encrypted, as <span class="keyword">in</span> .gitsecret/paths/mapping.cfg</span><br><span class="line"> remove [files] - removes files from list of hidden files</span><br><span class="line"> reveal - decrypts all hidden files, as mentioned <span class="keyword">in</span> <span class="string">'git secret list'</span></span><br><span class="line"> tell [email] - add access <span class="keyword">for</span> the user with imported public key with email</span><br><span class="line"> whoknows - shows list of email addresses associated with public keys that can reveal files</span><br></pre></td></tr></table></figure><h1 id="사용-예시"><a href="#사용-예시" class="headerlink" title="사용 예시"></a>사용 예시</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># gpg 키 생성</span></span><br><span class="line"><span class="comment">#   - Real Name, E-Mail 입력</span></span><br><span class="line"><span class="comment">#.  - --full-generate-key 옵션은 Mac OS X에서 사용합니다.</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">$ gpg --full-generate-key</span><br><span class="line">또는</span><br><span class="line">$ gpg --gen-key</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># git-secret 초기화</span></span><br><span class="line"><span class="comment">#.  - 명령어 : git-secret init</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">$ git-secret init</span><br><span class="line"><span class="string">'/Users/jhyunto/Documents/workspace/oauth2.0-cookbook/.gitsecret/'</span> created.</span><br><span class="line">cleaning up...</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 사용자 추가</span></span><br><span class="line"><span class="comment">#.  - git-secret </span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">$ git secret tell jhyunto@gmail.com</span><br><span class="line">gpg: keybox <span class="string">'/Users/hyunsoo0813/Documents/workspace/oauth2.0-cookbook/.gitsecret/keys/pubring.kbx'</span> created</span><br><span class="line">gpg: /Users/hyunsoo0813/Documents/workspace/oauth2.0-cookbook/.gitsecret/keys/trustdb.gpg: trustdb created</span><br><span class="line"><span class="keyword">done</span>. jhyunto@gmail.com added as someone who know(s) the secret.</span><br><span class="line">cleaning up...</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 파일 추가</span></span><br><span class="line"><span class="comment">#   - 추가할 파일이 git tracked 중 이라면 먼저 제거해야 합니다. : git rm --cached &lt;filename&gt;</span></span><br><span class="line"><span class="comment">#.  - 명령어 : git-secret add &lt;filename&gt;</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">$ git rm --cached client-implicit/src/main/resources/application.properties</span><br><span class="line">rm <span class="string">'client-implicit/src/main/resources/application.properties'</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'client-implicit/src/main/resources/application.properties'</span> &gt;&gt; .gitignore</span><br><span class="line">$ git-secret add client-implicit/src/main/resources/application.properties</span><br><span class="line">1 item(s) added.</span><br><span class="line"></span><br><span class="line">$ git rm --cached social-authcode/src/main/resources/application.properties</span><br><span class="line">rm <span class="string">'social-authcode/src/main/resources/application.properties'</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'social-authcode/src/main/resources/application.properties'</span> &gt;&gt; .gitignore</span><br><span class="line">$ git-secret add social-authcode/src/main/resources/application.properties</span><br><span class="line">1 item(s) added.</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 암호화</span></span><br><span class="line"><span class="comment">#   - 명령어 : git-secret hide</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">$ git-secret hide</span><br><span class="line"><span class="keyword">done</span>. all 1 files are hidden.</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 복호화</span></span><br><span class="line"><span class="comment">#   - 명령어 : git-secret reveal</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">$ git-secret reveal</span><br><span class="line">File <span class="string">'/Users/hyunsoo0813/Documents/workspace/oauth2.0-cookbook/client-implicit/src/main/resources/application.properties'</span> exists. Overwrite? (y/N) y</span><br><span class="line">File <span class="string">'/Users/hyunsoo0813/Documents/workspace/oauth2.0-cookbook/social-authcode/src/main/resources/application.properties'</span> exists. Overwrite? (y/N) y</span><br><span class="line">File <span class="string">'/Users/hyunsoo0813/Documents/workspace/oauth2.0-cookbook/social-linkd-in/src/main/resources/application.properties'</span> exists. Overwrite? (y/N) y</span><br><span class="line"><span class="keyword">done</span>. all 3 files are revealed.</span><br></pre></td></tr></table></figure><blockquote><p><strong>Reference</strong></p><ul><li><a href="http://git-secret.io/" rel="external nofollow noopener noreferrer" target="_blank">git-secret.io</a></li><li><a href="https://www.thoughtworks.com/de/radar/tools/git-secrets" rel="external nofollow noopener noreferrer" target="_blank">Thoughworks Technology Radar Vol.19 - git-secrets</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;비밀번호, Secret Key 값과 같이 보호되야 하는 데이터가 포함된 파일을 그냥 Git Commit &amp;amp; Push 하면 개인적인 데이터가 노출되는 문제점이 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git-secret&lt;/code&gt; 을 사용하면 개인적인 데이터가 포함된 파일을 암호화 한 후에 Git 저장소에 저장함으로써 문제점을 해결할 수 있습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://hyunto.github.io/categories/Tool/"/>
    
    
      <category term="git" scheme="https://hyunto.github.io/tags/git/"/>
    
      <category term="git-secret" scheme="https://hyunto.github.io/tags/git-secret/"/>
    
  </entry>
  
  <entry>
    <title>동작 파라미터화 (Behavior Parameterization)</title>
    <link href="https://hyunto.github.io/2018/12/03/Java8-Behavior-Parameterization/"/>
    <id>https://hyunto.github.io/2018/12/03/Java8-Behavior-Parameterization/</id>
    <published>2018-12-03T14:51:31.000Z</published>
    <updated>2019-08-08T14:23:01.942Z</updated>
    
    <content type="html"><![CDATA[<p><code>동작 파라미터화 (Behavior Parameterization)</code> 는 “다양한 동작을 수행할 수 있는 코드 블럭을 메서드 파라미터로 전달”함으로써 자주 변경되는 요구사항에 효과적으로 대응할 수 있는 방식을 의미합니다.</p><p>여기서는 자주 변경되는 요구사항의 예시를 기반으로 동작 파라미터화를 한 후 Java8에서 추가된 Lambda로 코드를 간소화하는 과정을 보여줍니다.</p><a id="more"></a><h2 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h2><p>우리는 농장 재고 애플리케이션을 개발합니다. 농부는 <code>녹색 사과</code> 만 필터링 하는 기능을 추가하길 원했습니다.</p><h2 id="시도-1-녹색-사과-필터링"><a href="#시도-1-녹색-사과-필터링" class="headerlink" title="시도 1 : 녹색 사과 필터링"></a>시도 1 : 녹색 사과 필터링</h2><p>아래와 같이 녹색 사과만 필터링하는 메서드를 구현했습니다.<br>그런데 농부가 <code>빨간 사과</code> 를 필터링하는 기능을 추가하길 원했습니다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">(List&lt;Apple&gt; inventory)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"green"</span>.equals(apple.getColor())) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="시도-2-색을-파라미터화"><a href="#시도-2-색을-파라미터화" class="headerlink" title="시도 2 : 색을 파라미터화"></a>시도 2 : 색을 파라미터화</h2><p>메서드의 파라미터로 색을 추가하여 유연하게 개선했습니다.<br>그런데 이번엔  <code>150g 이상 무게가 나가는 사과</code> 를 필터링하길 원했습니다. <em>즉, 필터의 기준이 계속해서 변경될 가능성이 존재합니다.</em></p><p>아래와 같이 파라미터(color, weight)를 다르게 하여 원하는 결과를 얻을 수 있지만 중복된 코드가 존재합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 색(Color)를 기준으로 필터링</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApplesByColor</span><span class="params">(List&lt;Apple&gt; inventory, String color)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple.getColor().equals(color)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 무게(Weight)를 기준으로 필터링</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApplesByWeight</span><span class="params">(List&lt;Apple&gt; inventory, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple.getWeight() &gt; weight) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="시도-3-가능한-모든-속성으로-필터링"><a href="#시도-3-가능한-모든-속성으로-필터링" class="headerlink" title="시도 3 : 가능한 모든 속성으로 필터링"></a>시도 3 : 가능한 모든 속성으로 필터링</h2><p>앞서 농부가 요구했던 “색”과 “무게” 요구사항을 모두 합친 필터링 메서드를 구현합니다.<br>그러나 이 방식은 많은 문제점이 존재합니다.</p><p>만약 농부가 “150g 이상의 빨간 사과를 필터링”하고 싶어 한다면 또다시 코드가 중복되는 비슷한 메서드를 추가하거나, 조건절이 늘어나는 거대한 메서드를 만들게 될 것입니다.<br>또한 파라미터의 <code>flag</code> 값의 의미를 단번에 알 수 없습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory, String color, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> weight, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp;&amp; apple.getColor().equals(color)) </span><br><span class="line">            || (!flag &amp;&amp; apple.getWeight() &gt; weight)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; greenApples = filterApples(inventory, <span class="string">"green"</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">List&lt;Apple&gt; heavyApples = filterApples(inventory, <span class="string">""</span>, <span class="number">150</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h2 id="시도-4-동작-파라미터화"><a href="#시도-4-동작-파라미터화" class="headerlink" title="시도 4 : 동작 파라미터화"></a>시도 4 : 동작 파라미터화</h2><p>사과의 어떤 속성에 기초하여 Boolena 값을 반환하는 메서드를 가진 인터페이스를 사용합니다. 이와 같은 동작을 <code>프레디케이트 (Predicate)</code> 라고 합니다.</p><blockquote><p><strong>Predicate</strong> 의 사전적 의미는 “술어” 입니다.<br><strong>술어</strong> 의 사전적 의미는 “논리의 판단. 명제에서 주사에 대하여 긍정 또는 부정의 입언을 하는 개념” 입니다.</p></blockquote><p>아래의 예제에선 <code>전략 디자인 패턴 (Strategy Design Pattern)</code> 을 사용하여 사과를 선택하는 조건을 캡슐화 했습니다.<br>전략 디자인 패턴 (Strategy Design Pattern)은 각 알고리즘을 캡슐화하는 알고리즘 패밀리를 정의해 두고, 런타임에 알고리즘을 선택하는 기법입니다.<br>여기서 “알고리즘 패밀리”는 <code>AppleHeavyWeightPredicate</code> 메서드와 <code>AppleGreenColorPredicate</code> 메서드`가 됩니다.</p><p>만약 농부가 새로운 필터링 조건을 요구하더라도 <code>ApplePredicate 인터페이스</code> 를 구현하는 메서드를 추가하면 됩니다.<br>이와 같이 메서드의 파라미터로 코드 블럭을 전달함으로써 메서드의 동작을 파라미터화 한 것 입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span> <span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"green"</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 색과 무게를 동시에 필터링 조건으로 갖는 메서드(전략 or 알고리즘 패밀리) 추가</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleRedAndHeavyPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory, ApplePredicate p)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(apple)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 녹색 사과만 필터링</span></span><br><span class="line">List&lt;Apple&gt; greeApples = filterApples(inventory, <span class="keyword">new</span> AppleGreenColorPredicate());</span><br><span class="line"><span class="comment">// 무게가 150g 이상인 사과만 필터링</span></span><br><span class="line">List&lt;Apple&gt; heavyApples = filterApples(inventory, <span class="keyword">new</span> AppleHeavyWeightPredicate());</span><br></pre></td></tr></table></figure><h2 id="시도-5-익명-클래스를-통한-코드-간소화"><a href="#시도-5-익명-클래스를-통한-코드-간소화" class="headerlink" title="시도 5 : 익명 클래스를 통한 코드 간소화"></a>시도 5 : 익명 클래스를 통한 코드 간소화</h2><p>앞선 예제는 동작 파라미터화를 위해 여러 개의 클래스를 정의했습니다.<br><code>익명 클래스 (Anonymous Class)</code> 를 통해 클래스 정의 없이 필터링 구현이 가능합니다.</p><p>그러나 자칫하면 익명 클래스로 인해 코드가 장황해져 유지보수가 어려워 질 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빨간 사과만 필터링</span></span><br><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, <span class="keyword">new</span> ApplePredicate() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="시도-6-람다-표현식-사용"><a href="#시도-6-람다-표현식-사용" class="headerlink" title="시도 6 : 람다 표현식 사용"></a>시도 6 : 람다 표현식 사용</h2><p>자바8의 람다 표현식으로 위 예제 코드를 간단하게 구현할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, (Apple apple) -&gt; <span class="string">"red"</span>.equals(apple.getColor()));</span><br></pre></td></tr></table></figure><h2 id="시도-7-리스트-형식으로-추상화"><a href="#시도-7-리스트-형식으로-추상화" class="headerlink" title="시도 7 : 리스트 형식으로 추상화"></a>시도 7 : 리스트 형식으로 추상화</h2><p>사과 이외에도 다양한 물건을 필터링 할 수 있도록 추상화 할 수 있습니다. (Generic 사용)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T e: list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(e)) &#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 빨간 사과 필터링</span></span><br><span class="line">List&lt;Apple&gt; redApples = filter(inventory, (Apple apple) -&gt; <span class="string">"red"</span>.equals(apple.getColor()));</span><br><span class="line"><span class="comment">// 짝수 필터링</span></span><br><span class="line">List&lt;String&gt; evenNumbers = filter(numbers, (Integer i) -&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;동작 파라미터화 (Behavior Parameterization)&lt;/code&gt; 는 “다양한 동작을 수행할 수 있는 코드 블럭을 메서드 파라미터로 전달”함으로써 자주 변경되는 요구사항에 효과적으로 대응할 수 있는 방식을 의미합니다.&lt;/p&gt;
&lt;p&gt;여기서는 자주 변경되는 요구사항의 예시를 기반으로 동작 파라미터화를 한 후 Java8에서 추가된 Lambda로 코드를 간소화하는 과정을 보여줍니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://hyunto.github.io/categories/Programming/"/>
    
    
      <category term="Java" scheme="https://hyunto.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://hyunto.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>[Book Review] 자바 ORM 표준 JPA 프로그래밍</title>
    <link href="https://hyunto.github.io/2018/11/16/Book-Review-%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    <id>https://hyunto.github.io/2018/11/16/Book-Review-자바-ORM-표준-JPA-프로그래밍/</id>
    <published>2018-11-15T23:30:23.000Z</published>
    <updated>2019-08-08T14:23:01.922Z</updated>
    
    <content type="html"><![CDATA[<p>자바 ORM 표준 JPA 프로그래밍 (2015) 독서/스터디 후기</p><a id="more"></a><p><img src="book_cover.png" alt="자바 ORM 표준 JPA 프로그래밍"></p><h2 id="읽게-된-계기"><a href="#읽게-된-계기" class="headerlink" title="읽게 된 계기"></a>읽게 된 계기</h2><p>현재 업무 중 JPA를 사용 중 입니다.<br>그러나 Spring Boot와 관련된 얇은 책을 읽고 나서 그것을 따라서 사용하는 정도였습니다.<br>원리를 정확히 이해하지 않은채로 사용 중이었기 때문에 조금만 복잡해지면 쉽게 막혔습니다.<br>그러던 중 다른 팀에 계신 과장님이 이 책을 추천해 주셨습니다.<br>이 책을 통해 JPA에 좀 더 친숙해지길 기대합니다.</p><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>다 읽은 후 작성합니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;자바 ORM 표준 JPA 프로그래밍 (2015) 독서/스터디 후기&lt;/p&gt;
    
    </summary>
    
      <category term="Book Review" scheme="https://hyunto.github.io/categories/Book-Review/"/>
    
    
      <category term="JPA" scheme="https://hyunto.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://hyunto.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>자주 사용하는 Docker 명령어 정리</title>
    <link href="https://hyunto.github.io/2018/07/27/%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-Docker-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/"/>
    <id>https://hyunto.github.io/2018/07/27/자주-사용하는-Docker-명령어-정리/</id>
    <published>2018-07-27T04:29:19.000Z</published>
    <updated>2019-08-08T14:23:01.922Z</updated>
    
    <content type="html"><![CDATA[<p>업무 중 자주 사용되는 Docker CLI명령어와 Dockerfile 키워드를 정리합니다.<br>또한 업무중 겪었던 Docker 관련 이슈를 정리합니다.</p><a id="more"></a><h1 id="Docker-CLI"><a href="#Docker-CLI" class="headerlink" title="Docker CLI"></a>Docker CLI</h1><p>업무 중 자주 사용하는 Docker 명령어를 정리합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Docker 이미지 검색</span></span><br><span class="line">$ docker search &#123;image&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 이미지 다운로드</span></span><br><span class="line">$ docker pull &#123;image&#125;:&#123;tag&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 이미지 목록 확인</span></span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 이미지 삭제</span></span><br><span class="line">$ docker rmi &#123;image&#125;:&#123;tag&#125;</span><br><span class="line">$ docker rmi &#123;image_id&#125;</span><br><span class="line">$ docker rmi &#123;image_id&#125; --force</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 생성</span></span><br><span class="line"><span class="comment">##  - 이 방법으로 Docker 컨테이너를 생성하면 곧 바로 컨테이너의 콘솔로 접속됩니다.</span></span><br><span class="line"><span class="comment">##  - 컨테이너에서 나오기 위해 exit 명령어를 입력할 경우 컨테이너가 종료됩니다.</span></span><br><span class="line"><span class="comment">##  - 다시 접속하려면 Docker 컨테이너를 시작한 후에 가능합니다.</span></span><br><span class="line"><span class="comment">##  - --name 옵션을 명시하지 않을 경우 &#123;container_name&#125; 임의의 컨테이너 이름이 생성됩니다. </span></span><br><span class="line"><span class="comment">##  - &#123;container_name&#125; 대신 &#123;container_id&#125;를 사용할 수 있습니다.</span></span><br><span class="line">$ docker run -it --name &#123;container_name&#125; &#123;image&#125; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 목록 확인 (전체)</span></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 목록 확인 (실행 중)</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 시작 / 재시작 / 종료</span></span><br><span class="line">$ docker start &#123;container_name&#125;</span><br><span class="line">$ docker restart &#123;container_name&#125;</span><br><span class="line">$ docker stop &#123;container_name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 접속</span></span><br><span class="line"><span class="comment">##  - 이 방법으로 Docker 컨테이너 접속 후 빠져나오기 위해 exit 명령어를 실행하면 컨테이너가 종료됩니다. </span></span><br><span class="line">$ docker attach &#123;container_name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 접속 (exit 명령어를 실행해도 Docker 컨테이너가 종료되지 않음)</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it &#123;container_name&#125; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">## 외부에서 Docker 컨테이너 안의 명령 실행하기</span></span><br><span class="line"><span class="comment">##  - 예제 : docker exec ubuntu_test cat /etc/lsb-release</span></span><br><span class="line">$ docker <span class="built_in">exec</span> &#123;container_name&#125; &#123;<span class="built_in">command</span>&#125; &#123;parameters&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker 컨테이너 삭제</span></span><br><span class="line">$ docker rm &#123;container_name&#125;</span><br></pre></td></tr></table></figure><h1 id="Docker-Image-만들기"><a href="#Docker-Image-만들기" class="headerlink" title="Docker Image 만들기"></a>Docker Image 만들기</h1><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>작성 중…</p><h1 id="일반-계정으로-docker-명령어-사용하기"><a href="#일반-계정으로-docker-명령어-사용하기" class="headerlink" title="일반 계정으로 docker 명령어 사용하기"></a>일반 계정으로 docker 명령어 사용하기</h1><p>콘솔에서 docker 명령어는 root 권한을 가진 사용자만 사용할 수 있습니다.<br>그래서 docker 명령어 실행시 항상 sudo를 붙여야 합니다. 만약 일반 계정으로 sudo를 붙이지 않고 docker 명령어를 실행하면 다음과 같은 메세지를 출력합니다.<br><code>Cannot connect to the Docker daemon. Is the docker daemon running on this host?</code></p><p>그러나 docker 그룹을 생성한 후 일반 사용자를 포함하면 일반 계정도 sudo를 붙이지 않고 docker 명령어를 사용할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$&#123;USER&#125;</span> 또는 sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;업무 중 자주 사용되는 Docker CLI명령어와 Dockerfile 키워드를 정리합니다.&lt;br&gt;또한 업무중 겪었던 Docker 관련 이슈를 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://hyunto.github.io/categories/DevOps/"/>
    
    
      <category term="Docker" scheme="https://hyunto.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 사용법</title>
    <link href="https://hyunto.github.io/2018/07/26/Hexo-%EC%82%AC%EC%9A%A9%EB%B2%95/"/>
    <id>https://hyunto.github.io/2018/07/26/Hexo-사용법/</id>
    <published>2018-07-26T09:41:29.000Z</published>
    <updated>2019-08-08T14:23:01.921Z</updated>
    
    <content type="html"><![CDATA[<p>2018년 초, Hexo를 사용해 이 블로그를 만들었으나 집, 회사 PC에서 블로그 Source를 다운받아 Deploy하는 과정에서 여러번 블로그를 망가뜨려 버렸습니다.<br>같은 실수를 반복하지 않기 위해 블로그 소스코드 다운, 빌드, 배포와 글을 작성하는 방법을 간단히 정리합니다.</p><a id="more"></a><h1 id="Download-Build-Deploy"><a href="#Download-Build-Deploy" class="headerlink" title="Download, Build, Deploy"></a>Download, Build, Deploy</h1><p>Hexo는 Jikyll과 다르게 GitHub Page로 배포되는 소스와 원본 소스가 분리되어 있기 때문에 2개의 GitHub Repository를 생성해야 합니다.</p><ul><li><a href="https://github.com/hyunto/hyunto.github.io" rel="external nofollow noopener noreferrer" target="_blank">hyunto/hyunto.github.io</a> : GitHub Page</li><li><a href="https://github.com/hyunto/hyunto.github.io-source" rel="external nofollow noopener noreferrer" target="_blank">hyunto/hyunto.github.io-source</a> : Hexo</li></ul><p>따라서 주로 <a href="https://github.com/hyunto/hyunto.github.io-source" rel="external nofollow noopener noreferrer" target="_blank">hyunto/hyunto.github.io-source</a>를 주로 다운로드 한 후 배포하는데, 매번 실수로 Hexo 테마 소스를 빌드하지 않고 배포하여 블로그 페이지가 깨져버렸습니다. 처음에는 프론트엔드 쪽 지식이 부족해서 원인을 찾지 못하다가 최근 Vue.js를 공부하면서 문득 프론트엔드 빌드를 하지 않았다는 사실을 깨닳았습니다. 이번엔 빌드를 하려니 제대로 되지 않아 Tranquilpeak Hexo 테마 버전을 1.11.0에서 3.0.0 버전으로 업그레이드하여 빌드를 성공했습니다.</p><p>참고로 Tranquilpeak Hexo 테마 3.0.0 버전은 Font Awesome 버전 업그레이드를 했으나 이를 제대로 반영하지 않아 버그가 존재합니다. 이 블로그는 현재까지 발견된 버그를 직접 수정했습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># GitHub에서 소스코드 다운로드 및 Git Config 설정</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/hyunto/hyunto.github.io-source.git</span><br><span class="line">$ <span class="built_in">cd</span> hyunto.github.io-source</span><br><span class="line">$ git config --<span class="built_in">local</span> user.name jhyunto</span><br><span class="line">$ git config --<span class="built_in">local</span> user.email jhyunto@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Hexo Tranquilpeak 테마 의존성 설치 및 빌드</span></span><br><span class="line"><span class="comment"># 참고로 내가 사용하는 테마는 LouisBarranqueiro/hexo-theme-tranquilpeak 이고, 2.0.0 Release 부터 Bower를 더 이상 사용하지 않습니다.</span></span><br><span class="line"><span class="comment"># 따라서 의존성 설치시 bower install 명령어를 실행하지 않습니다.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">$ <span class="built_in">cd</span> themes/tranquilpeak</span><br><span class="line">$ npm install</span><br><span class="line">$ grunt build</span><br><span class="line">$ grunt buildProd</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Hexo 의존성 설치 및 Hexo 서버 실행</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">$ <span class="built_in">cd</span> ./../../</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h1 id="블로그-글쓰기"><a href="#블로그-글쓰기" class="headerlink" title="블로그 글쓰기"></a>블로그 글쓰기</h1><h2 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h2><p>Hexo에는 초안 작성을 위한 <code>Draft</code> 와 즉시 배포를 위한 <code>Post</code> 가 있습니다. (<code>Page</code> 라는 것도 있으나 사용하지 않습니다.)</p><p>일관된 포맷으로 블로그 글을 작성하기 위해 템플릿 파일을 사용합니다. <code>scaffolds/draft.md</code> 파일과 <code>scaffolds/post.md</code> 파일을 나만의  템플릿으로 수정했습니다. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#123;&#123;</span> <span class="string">title</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span></span><br><span class="line"><span class="attr">thumbnailImage:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="bullet">--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Draft-또는-Post-생성-및-배포"><a href="#Draft-또는-Post-생성-및-배포" class="headerlink" title="Draft 또는 Post 생성 및 배포"></a>Draft 또는 Post 생성 및 배포</h2><p>블로그에 즉시 글을 올리려면 <code>Post</code> 를 생성하고, 초안을 작성하다가 완성 후에 올리려면 <code>Draft</code> 를 생성합니다.<br><code>Draft</code> 는 초안이기 때문에 <code>deploy</code> 명령어를 통해 배포되지 않습니다. 완성된 <code>Draft</code> 를 배포하려면 <code>publish</code> 명령어를 사용합니다.<br><code>publish</code> 명령어는 <code>source/_drafts</code> 에 있던 초안을 <code>source/_posts</code> 디렉토리로 옮겨주는 역할을 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Post 생성</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">$ hexo new post <span class="string">"New Post Title"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Draft 생성 및 Publish</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">$ hexo new draft <span class="string">'New Draft Title'</span></span><br><span class="line">$ hexo publish <span class="string">'New Draft Title'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 배포</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo algolia</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h2 id="글-원본-관리"><a href="#글-원본-관리" class="headerlink" title="글 원본 관리"></a>글 원본 관리</h2><p>새로 작성한 블로그 포스트를 배포한 후에는 반드시 git commit을 해야 합니다. 그렇지 않으면 원본 Markdown 파일을 손실할 수도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"commit_message"</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018년 초, Hexo를 사용해 이 블로그를 만들었으나 집, 회사 PC에서 블로그 Source를 다운받아 Deploy하는 과정에서 여러번 블로그를 망가뜨려 버렸습니다.&lt;br&gt;같은 실수를 반복하지 않기 위해 블로그 소스코드 다운, 빌드, 배포와 글을 작성하는 방법을 간단히 정리합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="https://hyunto.github.io/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="https://hyunto.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
